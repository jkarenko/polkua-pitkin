<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trace Route Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; touch-action: none; }
        canvas { display: block; background-color: #ffffff; cursor: crosshair; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            display: flex;
            align-items: center;
        }
        #doneButton, #resetButton {
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 10px;
        }
        #status {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="doneButton">Done Drawing</button>
        <button id="resetButton" style="display: none;">Reset Game</button>
        <div id="status">Player 1: Draw a path.</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const doneButton = document.getElementById('doneButton');
        const resetButton = document.getElementById('resetButton');
        const statusDiv = document.getElementById('status');

        // --- Constants ---
        const P1_COLOR = 'blue';
        const P1_WIDTH = 20;
        const P2_COLOR = 'black';
        const P2_WIDTH = 3;
        const START_COLOR = 'gray';
        const END_COLOR = 'green';
        const MARKER_RADIUS_FACTOR = 1.2; // Circle radius = line width * factor
        const HIT_THRESHOLD_FACTOR = 1.1; // Tolerance multiplier for staying within P1 trace
        const PROGRESS_INTERVAL = 0.10; // 10%
        const START_END_SNAP_RADIUS_FACTOR = 1.5; // Multiplier for start/end circle click radius

        // --- State ---
        let gameState = 'P1_DRAWING'; // 'P1_DRAWING', 'P2_WAITING', 'P2_DRAWING', 'P2_FINISHED'
        let player1Path = [];
        let player2Path = [];
        let isDrawing = false;
        let player1TotalLength = 0;
        let lastPlayedProgressMilestone = 0;
        let startMarker = null; // { x, y, radius }
        let endMarker = null; // { x, y, radius }
        let audioCtx = null;
        let hasInteracted = false; // For resuming audio context

        // --- Audio ---
        function initAudio() {
            if (!audioCtx && hasInteracted) {
                 try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                 } catch (e) {
                     console.error("Web Audio API is not supported in this browser", e);
                 }
            }
        }

        function playSound(type, pitchFactor = 0) {
             initAudio(); // Ensure context is active
             if (!audioCtx) return;

            // Resume context if suspended (common in browsers before user interaction)
             if (audioCtx.state === 'suspended') {
                audioCtx.resume();
             }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime); // Slightly increased volume

            if (type === 'alarm') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(180, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(120, audioCtx.currentTime + 0.3);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.4);
            } else if (type === 'chime') {
                const baseFrequency = 300;
                oscillator.type = 'sine';
                const frequency = baseFrequency * Math.pow(2, pitchFactor * 1.5); // Exponential pitch increase
                 oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                 gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'success') {
                const baseFreq = 523.25; // C5
                const freqs = [baseFreq, baseFreq * 1.25, baseFreq * 1.5]; // C, E, G
                let startTime = audioCtx.currentTime;
                 freqs.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gn = audioCtx.createGain();
                    osc.connect(gn);
                    gn.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, startTime + i * 0.15);
                    gn.gain.setValueAtTime(0.1, startTime + i * 0.15);
                    gn.gain.exponentialRampToValueAtTime(0.0001, startTime + i * 0.15 + 0.2);
                    osc.start(startTime + i * 0.15);
                    osc.stop(startTime + i * 0.15 + 0.2);
                 });
            }
        }

        // --- Helper Functions ---
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            const touch = e.touches && e.touches[0];
            x = (touch ? touch.clientX : e.clientX) - rect.left;
            y = (touch ? touch.clientY : e.clientY) - rect.top;
            // Adjust for CSS scaling
            x *= canvas.width / rect.width;
            y *= canvas.height / rect.height;
            return { x, y };
        }

        function distSq(p1, p2) {
            return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        }

        function dist(p1, p2) {
            return Math.sqrt(distSq(p1, p2));
        }

        function pointLineSegmentDistance(p, a, b) {
            const l2 = distSq(a, b);
            if (l2 === 0) return dist(p, a);
            let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
            return dist(p, projection);
        }

        function isPointWithinPath(point, path, threshold) {
            if (path.length < 2) return true; // Path is just a point or empty
            let minDistance = Infinity;
            for (let i = 0; i < path.length - 1; i++) {
                minDistance = Math.min(minDistance, pointLineSegmentDistance(point, path[i], path[i + 1]));
            }
             // Also check distance to the very first and last points explicitly
             if (path.length > 0) {
                 minDistance = Math.min(minDistance, dist(point, path[0]));
                 minDistance = Math.min(minDistance, dist(point, path[path.length - 1]));
             }
            return minDistance <= threshold;
        }

        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                length += dist(path[i], path[i + 1]);
            }
            return length;
        }

        function getProgressAlongPath(point, path) {
            if (path.length < 2 || player1TotalLength === 0) return 0;

            let minDistanceSq = Infinity;
            let lengthUpToProjection = 0;
            let accumulatedLength = 0;

            for (let i = 0; i < path.length - 1; i++) {
                const a = path[i];
                const b = path[i + 1];
                const segmentLength = dist(a, b);
                const l2 = distSq(a, b);
                let currentProjection = a;
                let t = 0;

                if (l2 !== 0) {
                    t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    currentProjection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                }

                const dSq = distSq(point, currentProjection);

                if (dSq < minDistanceSq) {
                    minDistanceSq = dSq;
                    lengthUpToProjection = accumulatedLength + t * segmentLength;
                }
                 accumulatedLength += segmentLength;
             }
             // Check distance to the last point as well
            const distToLastPointSq = distSq(point, path[path.length - 1]);
            if (distToLastPointSq < minDistanceSq) {
                lengthUpToProjection = accumulatedLength; // accumulatedLength is total length here
            }

            return lengthUpToProjection / player1TotalLength;
        }


        // --- Drawing Functions ---
         function drawPath(path, color, width) {
             if (path.length < 1) return;
             ctx.strokeStyle = color;
             ctx.lineWidth = width;
             ctx.lineCap = 'round';
             ctx.lineJoin = 'round';

             ctx.beginPath();
             ctx.moveTo(path[0].x, path[0].y);
             for (let i = 1; i < path.length; i++) {
                 ctx.lineTo(path[i].x, path[i].y);
             }
             ctx.stroke();
         }

        function drawCircle(center, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Player 1 path components if available
            if (startMarker && endMarker) {
                drawCircle(startMarker, startMarker.radius, START_COLOR);
                drawCircle(endMarker, endMarker.radius, END_COLOR);
                drawPath(player1Path, P1_COLOR, P1_WIDTH);
            } else if (player1Path.length > 0 && gameState === 'P1_DRAWING') {
                // Draw temporary P1 path while drawing
                drawPath(player1Path, P1_COLOR, P1_WIDTH);
            }


            // Draw Player 2 path if they are drawing or failed
            if (gameState === 'P2_DRAWING' || gameState === 'P2_WAITING') {
                 drawPath(player2Path, P2_COLOR, P2_WIDTH);
            }
        }

        // --- Game Logic ---
        function resetPlayer2() {
            player2Path = [];
            isDrawing = false;
            lastPlayedProgressMilestone = 0;
            gameState = 'P2_WAITING';
            statusDiv.textContent = 'Player 2: Retrace the path starting from the gray circle.';
            redrawAll();
        }

        function handleP1Done() {
             if (player1Path.length < 2) {
                 statusDiv.textContent = "Player 1: Path is too short. Please draw more.";
                 return;
             }

             gameState = 'P2_WAITING';
             isDrawing = false;
             doneButton.style.display = 'none';
             resetButton.style.display = 'inline-block';
             statusDiv.textContent = 'Player 2: Retrace the path starting from the gray circle.';

            player1TotalLength = calculatePathLength(player1Path);
            const markerRadius = P1_WIDTH / 2 * MARKER_RADIUS_FACTOR;
             startMarker = { ...player1Path[0], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };
             endMarker = { ...player1Path[player1Path.length - 1], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };

             redrawAll(); // Draw final P1 path with markers
        }

         function resetGame() {
            gameState = 'P1_DRAWING';
            player1Path = [];
            player2Path = [];
            isDrawing = false;
            player1TotalLength = 0;
            lastPlayedProgressMilestone = 0;
            startMarker = null;
            endMarker = null;
            doneButton.style.display = 'inline-block';
            resetButton.style.display = 'none';
            statusDiv.textContent = 'Player 1: Draw a path.';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
         }

        // --- Event Handlers ---
        function handleStart(e) {
             if (e.touches && e.touches.length > 1) return; // Ignore multi-touch
             e.preventDefault();
             hasInteracted = true; // User has interacted, safe to init audio
             initAudio(); // Attempt audio init if not already done

             const pos = getEventCoords(e);

             if (gameState === 'P1_DRAWING') {
                 isDrawing = true;
                 player1Path = [pos];
                 ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous P1 attempts if any
             } else if (gameState === 'P2_WAITING') {
                 // Check if starting inside the gray circle
                 if (startMarker && dist(pos, startMarker) <= startMarker.snapRadius) {
                     isDrawing = true;
                     player2Path = [pos]; // Start P2 path
                     lastPlayedProgressMilestone = 0;
                     gameState = 'P2_DRAWING';
                     statusDiv.textContent = 'Player 2: Tracing... Stay inside the blue line!';
                     redrawAll(); // Redraw to clear any previous failed P2 lines
                     drawPath(player2Path, P2_COLOR, P2_WIDTH); // Draw the first segment immediately
                 } else {
                    // Didn't start in the right place
                    statusDiv.textContent = 'Player 2: Start drawing inside the gray circle!';
                 }
             }
        }

        function handleMove(e) {
            if (!isDrawing || (e.touches && e.touches.length > 1)) return;
            e.preventDefault();

            const pos = getEventCoords(e);
            const lastPos = (gameState === 'P1_DRAWING' ? player1Path : player2Path).slice(-1)[0];

            // Avoid adding duplicate points if stationary
            if (pos.x === lastPos.x && pos.y === lastPos.y) return;

            if (gameState === 'P1_DRAWING') {
                player1Path.push(pos);
                // Draw segment dynamically
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = P1_COLOR;
                ctx.lineWidth = P1_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();

            } else if (gameState === 'P2_DRAWING') {
                const threshold = P1_WIDTH / 2 * HIT_THRESHOLD_FACTOR;
                if (!isPointWithinPath(pos, player1Path, threshold)) {
                    // Player 2 went out of bounds
                    playSound('alarm');
                    resetPlayer2();
                    statusDiv.textContent = 'Player 2: Outside the line! Restart from the gray circle.';
                } else {
                    // Still inside, continue drawing
                    player2Path.push(pos);
                    // Draw segment
                    ctx.beginPath();
                    ctx.moveTo(lastPos.x, lastPos.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = P2_COLOR;
                    ctx.lineWidth = P2_WIDTH;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();


                    // Check progress and play chime
                    const currentProgress = getProgressAlongPath(pos, player1Path);
                    const currentMilestone = Math.floor(currentProgress / PROGRESS_INTERVAL);

                    if (currentMilestone > lastPlayedProgressMilestone && currentProgress < 1.0) {
                         lastPlayedProgressMilestone = currentMilestone;
                         playSound('chime', currentProgress); // Pitch increases with progress
                    }

                    // Check if near the end (visual cue maybe, or for immediate win detection)
                    if (endMarker && dist(pos, endMarker) <= endMarker.snapRadius) {
                        // Optionally give visual feedback for being near the end
                    }
                }
            }
        }

        function handleEnd(e) {
            if (!isDrawing) return;
             if (e.touches && e.touches.length > 0) return; // Ending one finger in multi-touch
            e.preventDefault();


            if (gameState === 'P1_DRAWING') {
                isDrawing = false;
                 // Don't switch state here, wait for button click
                 if (player1Path.length < 2) {
                     statusDiv.textContent = "Player 1: Draw a path, then click 'Done'.";
                 } else {
                     statusDiv.textContent = "Player 1: Click 'Done' or continue drawing.";
                 }
            } else if (gameState === 'P2_DRAWING') {
                const lastPos = player2Path.slice(-1)[0];
                 isDrawing = false; // Stop drawing regardless

                // Check if the lift-off point is within the end circle
                if (endMarker && dist(lastPos, endMarker) <= endMarker.snapRadius) {
                    // Check if significant progress was made (e.g., >95%)
                    const finalProgress = getProgressAlongPath(lastPos, player1Path);
                    if (finalProgress >= 0.95) {
                        gameState = 'P2_FINISHED';
                        statusDiv.textContent = 'Player 2 Wins! Well traced!';
                        playSound('success');
                        // Keep the final trace visible
                        redrawAll(); // Ensure final state is drawn clean
                        drawPath(player2Path, P2_COLOR, P2_WIDTH); // Redraw P2 path over P1
                    } else {
                        // Reached end zone but didn't trace enough of the path
                        playSound('alarm');
                        resetPlayer2();
                        statusDiv.textContent = 'Player 2: Reached the end too early! Restart trace.';
                    }

                } else {
                    // Lifted finger outside the end zone - treat as failure/interruption
                    playSound('alarm');
                    resetPlayer2();
                     statusDiv.textContent = 'Player 2: Trace interrupted! Restart from the gray circle.';
                }
            }
        }


        // --- Initialization ---
        function resizeCanvas() {
            const controlsHeight = document.getElementById('controls').offsetHeight + 20; // Get actual height + margin
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight; // Adjust if controls overlay canvas significantly

             // Style setting needed if CSS dimensions are different
             canvas.style.width = `${window.innerWidth}px`;
             canvas.style.height = `${window.innerHeight}px`;

             redrawAll(); // Redraw contents after resize
        }

        // Setup Event Listeners
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseout', handleEnd); // Treat leaving canvas like mouseup

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false }); // Treat cancel like end

        doneButton.addEventListener('click', handleP1Done);
        resetButton.addEventListener('click', resetGame);

        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        resizeCanvas();
        resetGame(); // Initialize game state

    </script>
</body>
</html>
