<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Polkua Pitkin Peli</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; touch-action: none; }
        canvas { display: block; background-color: #ffffff; cursor: crosshair; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #doneButton, #resetButton {
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        #doneButton:hover, #resetButton:hover {
            background-color: #45a049;
        }
        #status {
            font-weight: bold;
            color: #333;
        }
        .width-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #widthSlider {
            width: 100px;
        }
        #widthValue {
            min-width: 40px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="doneButton">Valmis!</button>
        <button id="resetButton" style="display: none;">Uusi Peli</button>
        <div class="width-control">
            <label for="widthSlider">Polun leveys:</label>
            <input type="range" id="widthSlider" min="20" max="60" value="40">
            <span id="widthValue">40</span>
        </div>
        <div id="status">Pelaaja 1: Piirrä polku.</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const doneButton = document.getElementById('doneButton');
        const resetButton = document.getElementById('resetButton');
        const statusDiv = document.getElementById('status');

        // --- Constants ---
        const P1_COLOR = 'lightblue';
        let P1_WIDTH = 40;
        const P2_COLOR = 'black';
        const P2_WIDTH = 3;
        const START_COLOR = 'gray';
        const END_COLOR = 'green';
        const MARKER_RADIUS_FACTOR = 1.4; // Circle radius = line width * factor
        const HIT_THRESHOLD_FACTOR = 1.1; // Tolerance multiplier for staying within P1 trace
        const PROGRESS_INTERVAL = 0.10; // 10%
        const START_END_SNAP_RADIUS_FACTOR = 1.5; // Multiplier for start/end circle click radius

        // Car constants
        const CAR_WIDTH = 50;
        const CAR_HEIGHT = 20;
        const CAR_COLOR = '#FF4444';
        const CAR_PIXEL_SPEED = 2; // Base speed in pixels per frame
        const CAR_ANIMATION_INTERVAL = 16; // ~60fps
        const SMOOTHING_WINDOW = 10; // Number of points to use for smoothing
        const CURVATURE_WINDOW = 10; // Number of points to use for curvature calculation
        const MAX_CURVATURE = 0.9; // Maximum curvature value (1.0 would be a complete U-turn)
        const ACCELERATION_RATE = 0.005; // How quickly the car speeds up (0-1 per frame)
        const BASE_DECELERATION_RATE = 0.8; // Base deceleration rate (increased from 0.5)
        const CURVE_LOOK_AHEAD = 0.15; // How far ahead to look for curves (15% of path)
        const MAX_DECELERATION_RATE = 1.2; // Maximum deceleration rate when approaching sharp curves (increased from 0.8)
        const CURVE_PREPARATION_DISTANCE = 0.1; // How far before a curve to start preparing (10% of path)
        const FINISH_PREPARATION_DISTANCE = 0.2; // How far before finish to start slowing down (20% of path)
        const MIN_FINISH_SPEED = 0.3; // Minimum speed at finish line (30% of max speed)

        // --- State ---
        let gameState = 'P1_DRAWING'; // 'P1_DRAWING', 'P2_WAITING', 'P2_DRAWING', 'P2_FINISHED', 'CAR_ANIMATING'
        let player1Path = [];
        let smoothedPath = []; // Add this to store the smoothed path
        let player2Path = [];
        let isDrawing = false;
        let player1TotalLength = 0;
        let lastPlayedProgressMilestone = 0;
        let startMarker = null; // { x, y, radius }
        let endMarker = null; // { x, y, radius }
        let audioCtx = null;
        let hasInteracted = false; // For resuming audio context
        let currentActiveSegmentIndex = 0; // Add this to the state variables at the top
        let progressMarkers = []; // Array to store progress milestone points with their directions

        // Car state
        let carProgress = 0;
        let carAnimationFrame = null;
        let carPosition = { x: 0, y: 0 };
        let carAngle = 0;
        let currentWheelAngle = 0;
        let currentCarAngle = 0; // Add this to track current car angle
        let currentSpeed = 0; // Add this to track current speed
        const WHEEL_TURN_SPEED = 0.15; // Controls how quickly wheels turn (0-1)
        const CAR_TURN_SPEED = 0.1; // Controls how quickly car body turns (0-1)
        const INITIAL_SPEED = 0; // Start from rest

        // Add new state variables for sound management
        let engineSound = null;
        let lastAngleChange = 0;
        const TURN_THRESHOLD = 0.5; // Threshold for significant turns
        const SOUND_COOLDOWN = 500; // Minimum time between screech sounds in ms

        // --- Audio ---
        function initAudio() {
            if (!audioCtx && hasInteracted) {
                 try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                 } catch (e) {
                     console.error("Web Audio API is not supported in this browser", e);
                 }
            }
        }

        function playHonk(durations = [0.3], pauses = [0]) {
            if (!audioCtx) return;
            
            let currentTime = audioCtx.currentTime;
            
            // Ensure durations and pauses arrays are the same length
            const length = Math.max(durations.length, pauses.length);
            durations = durations.concat(Array(length - durations.length).fill(0.3));
            pauses = pauses.concat(Array(length - pauses.length).fill(0));
            
            // Play each honk in sequence
            for (let i = 0; i < length; i++) {
                const startTime = currentTime;
                
                // First horn tone
                const osc1 = audioCtx.createOscillator();
                const gain1 = audioCtx.createGain();
                osc1.connect(gain1);
                gain1.connect(audioCtx.destination);
                
                // Second horn tone (slightly higher pitch)
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.connect(gain2);
                gain2.connect(audioCtx.destination);
                
                // Set frequencies (using a minor third interval for a classic horn sound)
                const baseFreq = 400;
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(baseFreq, startTime);
                osc2.frequency.setValueAtTime(baseFreq * 1.189207115, startTime); // Minor third up
                
                // Set gains (slightly lower for the second tone)
                gain1.gain.setValueAtTime(0.08, startTime);
                gain2.gain.setValueAtTime(0.06, startTime);
                
                // Create a slight attack and release
                gain1.gain.linearRampToValueAtTime(0.08, startTime + 0.05);
                gain2.gain.linearRampToValueAtTime(0.06, startTime + 0.05);
                gain1.gain.exponentialRampToValueAtTime(0.0001, startTime + durations[i]);
                gain2.gain.exponentialRampToValueAtTime(0.0001, startTime + durations[i]);
                
                // Start and stop both oscillators
                osc1.start(startTime);
                osc2.start(startTime);
                osc1.stop(startTime + durations[i]);
                osc2.stop(startTime + durations[i]);
                
                // Add pause before next honk
                currentTime += durations[i] + pauses[i];
            }
        }

        function playSound(type, pitchFactor = 0) {
             initAudio(); // Ensure context is active
             if (!audioCtx) return;

            // Resume context if suspended (common in browsers before user interaction)
             if (audioCtx.state === 'suspended') {
                audioCtx.resume();
             }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime); // Slightly increased volume

            if (type === 'alarm') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(180, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(120, audioCtx.currentTime + 0.3);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.4);
            } else if (type === 'chime') {
                const baseFrequency = 300;
                oscillator.type = 'sine';
                const frequency = baseFrequency * Math.pow(2, pitchFactor * 1.5); // Exponential pitch increase
                 oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                 gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'success') {
                const baseFreq = 523.25; // C5
                const freqs = [baseFreq, baseFreq * 1.25, baseFreq * 1.5]; // C, E, G
                let startTime = audioCtx.currentTime;
                 freqs.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gn = audioCtx.createGain();
                    osc.connect(gn);
                    gn.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, startTime + i * 0.15);
                    gn.gain.setValueAtTime(0.1, startTime + i * 0.15);
                    gn.gain.exponentialRampToValueAtTime(0.0001, startTime + i * 0.15 + 0.2);
                    osc.start(startTime + i * 0.15);
                    osc.stop(startTime + i * 0.15 + 0.2);
                 });
            } else if (type === 'engine') {
                // Create a more complex engine sound using multiple oscillators
                const baseFreq = 100;
                const startTime = audioCtx.currentTime;
                
                // Main engine sound
                const mainOsc = audioCtx.createOscillator();
                const mainGain = audioCtx.createGain();
                mainOsc.connect(mainGain);
                mainGain.connect(audioCtx.destination);
                mainOsc.type = 'sawtooth';
                mainOsc.frequency.setValueAtTime(baseFreq, startTime);
                mainGain.gain.setValueAtTime(0.05, startTime);
                
                // Add some variation
                const varOsc = audioCtx.createOscillator();
                const varGain = audioCtx.createGain();
                varOsc.connect(varGain);
                varGain.connect(audioCtx.destination);
                varOsc.type = 'sine';
                varOsc.frequency.setValueAtTime(baseFreq * 1.5, startTime);
                varGain.gain.setValueAtTime(0.02, startTime);
                
                mainOsc.start(startTime);
                varOsc.start(startTime);
                
                // Store references for cleanup and speed control
                return { 
                    mainOsc, 
                    varOsc,
                    mainGain,
                    varGain,
                    baseFreq,
                    updateSpeed: (speed) => {
                        const speedFactor = speed / CAR_PIXEL_SPEED; // Normalize speed to 0-1
                        const minFreq = baseFreq * 0.5;  // Minimum frequency (idle)
                        const maxFreq = baseFreq * 1.5;  // Maximum frequency (full speed)
                        
                        // Calculate target frequency
                        const targetFreq = minFreq + (maxFreq - minFreq) * speedFactor;
                        
                        // Get current frequency
                        const currentFreq = mainOsc.frequency.value;
                        
                        // If we're decelerating (target frequency is lower than current)
                        if (targetFreq < currentFreq) {
                            // Start decreasing frequency much more gradually
                            const newFreq = Math.max(targetFreq, currentFreq * 0.98);
                            mainOsc.frequency.setValueAtTime(newFreq, audioCtx.currentTime);
                            varOsc.frequency.setValueAtTime(newFreq * 1.5, audioCtx.currentTime);
                        } else {
                            // Normal acceleration
                            mainOsc.frequency.setValueAtTime(targetFreq, audioCtx.currentTime);
                            varOsc.frequency.setValueAtTime(targetFreq * 1.5, audioCtx.currentTime);
                        }
                        
                        // Adjust volume with speed, starting to fade out earlier
                        const volumeFactor = 0.05 + (speedFactor * 0.05); // 0.05 to 0.1
                        // Start fading out volume when speed is below 30%
                        const fadeOutFactor = Math.max(0, (speedFactor - 0.3) / 0.7);
                        const finalVolumeFactor = volumeFactor * fadeOutFactor;
                        mainGain.gain.setValueAtTime(finalVolumeFactor, audioCtx.currentTime);
                        varGain.gain.setValueAtTime(finalVolumeFactor * 0.4, audioCtx.currentTime);
                    }
                };
            } else if (type === 'screech') {
                // Create a screeching sound
                const startTime = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, startTime);
                osc.frequency.linearRampToValueAtTime(1200, startTime + 0.2);
                gain.gain.setValueAtTime(0.1, startTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.3);
                
                osc.start(startTime);
                osc.stop(startTime + 0.3);
            } else if (type === 'honk') {
                // Single honk
                playHonk([0.3]);
            }
        }

        // --- Helper Functions ---
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            const touch = e.touches && e.touches[0];
            x = (touch ? touch.clientX : e.clientX) - rect.left;
            y = (touch ? touch.clientY : e.clientY) - rect.top;
            // Adjust for CSS scaling
            x *= canvas.width / rect.width;
            y *= canvas.height / rect.height;
            return { x, y };
        }

        function distSq(p1, p2) {
            return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        }

        function dist(p1, p2) {
            return Math.sqrt(distSq(p1, p2));
        }

        function pointLineSegmentDistance(p, a, b) {
            const l2 = distSq(a, b);
            if (l2 === 0) return dist(p, a);
            let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
            return dist(p, projection);
        }

        function isPointWithinPath(point, path, threshold) {
            if (path.length < 2) return true; // Path is just a point or empty
            
            // For Player 1's drawing phase, use the original behavior
            if (gameState === 'P1_DRAWING') {
                let minDistance = Infinity;
                for (let i = 0; i < path.length - 1; i++) {
                    minDistance = Math.min(minDistance, pointLineSegmentDistance(point, path[i], path[i + 1]));
                }
                if (path.length > 0) {
                    minDistance = Math.min(minDistance, dist(point, path[0]));
                    minDistance = Math.min(minDistance, dist(point, path[path.length - 1]));
                }
                return minDistance <= threshold;
            }
            
            // For Player 2's drawing phase, check against all segments up to current position plus look-ahead
            const lookAheadSegments = 3; // Number of segments to look ahead
            const startIdx = 0; // Always start from beginning
            const endIdx = Math.min(currentActiveSegmentIndex + lookAheadSegments, path.length - 1);
            
            let minDistance = Infinity;
            for (let i = startIdx; i <= endIdx; i++) {
                if (i < path.length - 1) {
                    minDistance = Math.min(minDistance, pointLineSegmentDistance(point, path[i], path[i + 1]));
                }
            }
            
            // If we're near the end of the current segment, advance to the next one
            if (currentActiveSegmentIndex < path.length - 1) {
                const currentSegmentEnd = path[currentActiveSegmentIndex + 1];
                if (dist(point, currentSegmentEnd) <= threshold * 1.5) {
                    currentActiveSegmentIndex++;
                }
            }
            
            return minDistance <= threshold;
        }

        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                length += dist(path[i], path[i + 1]);
            }
            return length;
        }

        function getProgressAlongPath(point, path) {
            if (path.length < 2 || player1TotalLength === 0) return 0;

            // For Player 1's drawing phase, use the original behavior
            if (gameState === 'P1_DRAWING') {
                let minDistanceSq = Infinity;
                let lengthUpToProjection = 0;
                let accumulatedLength = 0;

                for (let i = 0; i < path.length - 1; i++) {
                    const a = path[i];
                    const b = path[i + 1];
                    const segmentLength = dist(a, b);
                    const l2 = distSq(a, b);
                    let currentProjection = a;
                    let t = 0;

                    if (l2 !== 0) {
                        t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        currentProjection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                    }

                    const dSq = distSq(point, currentProjection);

                    if (dSq < minDistanceSq) {
                        minDistanceSq = dSq;
                        lengthUpToProjection = accumulatedLength + t * segmentLength;
                    }
                    accumulatedLength += segmentLength;
                }
                // Check distance to the last point as well
                const distToLastPointSq = distSq(point, path[path.length - 1]);
                if (distToLastPointSq < minDistanceSq) {
                    lengthUpToProjection = accumulatedLength;
                }

                return lengthUpToProjection / player1TotalLength;
            }

            // For Player 2's drawing phase, calculate progress based on current active segment
            let accumulatedLength = 0;
            let currentSegmentProgress = 0;

            // Calculate length up to current active segment
            for (let i = 0; i < currentActiveSegmentIndex; i++) {
                accumulatedLength += dist(path[i], path[i + 1]);
            }

            // Calculate progress within current segment
            if (currentActiveSegmentIndex < path.length - 1) {
                const currentStart = path[currentActiveSegmentIndex];
                const currentEnd = path[currentActiveSegmentIndex + 1];
                const segmentLength = dist(currentStart, currentEnd);
                const l2 = distSq(currentStart, currentEnd);
                
                if (l2 !== 0) {
                    const t = ((point.x - currentStart.x) * (currentEnd.x - currentStart.x) + 
                              (point.y - currentStart.y) * (currentEnd.y - currentStart.y)) / l2;
                    currentSegmentProgress = Math.max(0, Math.min(1, t)) * segmentLength;
                }
            }

            return (accumulatedLength + currentSegmentProgress) / player1TotalLength;
        }

        function calculateCurvature(progress, path) {
            if (path.length < 3) return 0;
            
            // Get points before and after current position
            const lookAhead = CURVATURE_WINDOW;
            const currentPoint = getPointAlongPath(progress, path);
            const prevPoint = getPointAlongPath(Math.max(0, progress - 0.01), path);
            const nextPoint = getPointAlongPath(Math.min(1, progress + 0.01), path);
            
            // Calculate vectors
            const v1 = { x: currentPoint.x - prevPoint.x, y: currentPoint.y - prevPoint.y };
            const v2 = { x: nextPoint.x - currentPoint.x, y: nextPoint.y - currentPoint.y };
            
            // Calculate angle between vectors
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            
            if (mag1 === 0 || mag2 === 0) return 0;
            
            const cosAngle = dot / (mag1 * mag2);
            // Clamp cosAngle to [-1, 1] to avoid floating point errors
            const clampedCos = Math.max(-1, Math.min(1, cosAngle));
            const angle = Math.acos(clampedCos);
            
            // Convert angle to curvature (0 to 1)
            // 0 = straight line, 1 = complete U-turn
            return Math.min(MAX_CURVATURE, angle / Math.PI);
        }

        function getSpeedMultiplier(curvature) {
            // Convert curvature (0 to MAX_CURVATURE) to speed multiplier (0.05 to 1.0)
            // Now at maximum curvature, speed will be reduced to 5% instead of 10%
            return 1.0 - (curvature / MAX_CURVATURE) * 0.95;
        }

        function getDecelerationRate(currentCurvature, upcomingCurvature) {
            // If there's a sharp curve coming up, decelerate more aggressively
            const curveFactor = Math.max(0, upcomingCurvature - currentCurvature);
            
            // Calculate how close we are to the curve
            const distanceToCurve = CURVE_LOOK_AHEAD - CURVE_PREPARATION_DISTANCE;
            const preparationFactor = Math.max(0, Math.min(1, distanceToCurve / CURVE_PREPARATION_DISTANCE));
            
            // Combine curve sharpness with preparation factor
            // Add extra deceleration for very sharp curves (curvature > 0.7)
            const extraSharpCurveFactor = Math.max(0, (upcomingCurvature - 0.7) / 0.2);
            const combinedFactor = (curveFactor + extraSharpCurveFactor) * preparationFactor;
            
            return BASE_DECELERATION_RATE + (combinedFactor * (MAX_DECELERATION_RATE - BASE_DECELERATION_RATE));
        }

        // --- Drawing Functions ---
         function drawPath(path, color, width, isDrawing = false) {
             if (path.length < 1) return;
             
             if (!isDrawing) {
                 // Draw the outline (black path with slightly larger width) only for completed paths
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = width + 4; // 2 pixels wider on each side
                 ctx.lineCap = 'round';
                 ctx.lineJoin = 'round';

                 ctx.beginPath();
                 ctx.moveTo(path[0].x, path[0].y);
                 for (let i = 1; i < path.length; i++) {
                     ctx.lineTo(path[i].x, path[i].y);
                 }
                 ctx.stroke();
             }

             // Draw the main colored path
             ctx.strokeStyle = color;
             ctx.lineWidth = width;
             ctx.lineCap = 'round';
             ctx.lineJoin = 'round';

             ctx.beginPath();
             ctx.moveTo(path[0].x, path[0].y);
             for (let i = 1; i < path.length; i++) {
                 ctx.lineTo(path[i].x, path[i].y);
             }
             ctx.stroke();

             // Draw the dashed guide line for Player 1's path on top of the main path
             if (!isDrawing && color === P1_COLOR) {
                 ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                 ctx.lineWidth = 1;
                 ctx.setLineDash([5, 5]); // Create dashed line pattern
                 ctx.lineCap = 'butt';
                 ctx.lineJoin = 'miter';
                 ctx.beginPath();
                 ctx.moveTo(path[0].x, path[0].y);
                 for (let i = 1; i < path.length; i++) {
                     ctx.lineTo(path[i].x, path[i].y);
                 }
                 ctx.stroke();
                 ctx.setLineDash([]); // Reset dash pattern
             }
         }

        function drawCircle(center, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDirectionalMarker(point, direction, color = 'rgba(0, 0, 0, 0.3)') {
            const arrowLength = P1_WIDTH * 0; // Length of the arrow
            const arrowWidth = P1_WIDTH * 0.2; // Reduced width of the arrow head for a thinner line
            
            ctx.save();
            ctx.translate(point.x, point.y);
            ctx.rotate(Math.atan2(direction.y, direction.x));
            
            // Draw arrow head as two lines
            ctx.beginPath();
            ctx.moveTo(arrowLength, 0);
            ctx.lineTo(arrowLength - arrowWidth, -arrowWidth / 2);
            ctx.moveTo(arrowLength, 0);
            ctx.lineTo(arrowLength - arrowWidth, arrowWidth / 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1; // Set a thin line width
            ctx.stroke();
            
            ctx.restore();
        }

        function drawCar(position, angle) {
            ctx.save();
            ctx.translate(position.x, position.y);
            ctx.rotate(angle);
            
            // Calculate average direction vector for front wheels
            const lookAheadPoints = 5; // Number of points to look ahead
            let avgDirection = { x: 0, y: 0 };
            let count = 0;
            
            // Get points ahead of current position
            for (let i = 0; i < lookAheadPoints; i++) {
                const aheadProgress = Math.min(1, carProgress + (i + 1) * 0.02);
                const aheadPoint = getPointAlongPath(aheadProgress, player1Path);
                if (aheadPoint) {
                    avgDirection.x += aheadPoint.x - position.x;
                    avgDirection.y += aheadPoint.y - position.y;
                    count++;
                }
            }
            
            // Normalize average direction
            if (count > 0) {
                const length = Math.sqrt(avgDirection.x * avgDirection.x + avgDirection.y * avgDirection.y);
                if (length > 0) {
                    avgDirection.x /= length;
                    avgDirection.y /= length;
                }
            }
            
            // Calculate target wheel angle based on average direction
            const targetWheelAngle = Math.atan2(avgDirection.y, avgDirection.x) - angle;
            
            // Smoothly interpolate current wheel angle towards target
            const angleDiff = targetWheelAngle - currentWheelAngle;
            // Normalize angle difference to [-PI, PI]
            const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
            currentWheelAngle += normalizedDiff * WHEEL_TURN_SPEED;
            
            // Draw wheels with rotation
            ctx.save();
            ctx.translate(CAR_WIDTH/2 - 10, -CAR_HEIGHT/2);
            ctx.rotate(currentWheelAngle);
            ctx.fillStyle = '#000';
            ctx.fillRect(-5, -1, 10, 2);
            ctx.restore();
            
            ctx.save();
            ctx.translate(CAR_WIDTH/2 - 10, CAR_HEIGHT/2);
            ctx.rotate(currentWheelAngle);
            ctx.fillStyle = '#000';
            ctx.fillRect(-5, -1, 10, 2);
            ctx.restore();
            
            // Draw rear wheels (static)
            ctx.fillStyle = '#000';
            ctx.fillRect(-CAR_WIDTH/2 + 8, -CAR_HEIGHT/2 - 1, 10, 2);
            ctx.fillRect(-CAR_WIDTH/2 + 8, CAR_HEIGHT/2 - 1, 10, 2);
            
            // Draw car body
            ctx.fillStyle = CAR_COLOR;
            ctx.fillRect(-CAR_WIDTH/2, -CAR_HEIGHT/2, CAR_WIDTH, CAR_HEIGHT);

            // Draw car roof with multiply blend mode for realistic darkening
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';  // Use black with 30% opacity
            ctx.fillRect(-CAR_WIDTH/4, -CAR_HEIGHT/2, CAR_WIDTH/2, CAR_HEIGHT);
            ctx.globalCompositeOperation = 'source-over';  // Reset to default blend mode

            // Draw windows (in top-down perspective)
            ctx.fillStyle = '#4a90e2';  // Light blue color for windows
            // Rear windshield
            ctx.beginPath();
            ctx.moveTo(-CAR_WIDTH/4, -CAR_HEIGHT/2 + 3);
            ctx.lineTo(-CAR_WIDTH/4, CAR_HEIGHT/2 - 3);
            ctx.lineTo(-CAR_WIDTH/2 + 4, CAR_HEIGHT/2);
            ctx.lineTo(-CAR_WIDTH/2 + 4, -CAR_HEIGHT/2);
            ctx.closePath();
            ctx.fill();
            
            // Front windshield
            ctx.beginPath();
            ctx.moveTo(CAR_WIDTH/4, -CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4, CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4 - 3, CAR_HEIGHT/2 - 5);
            ctx.lineTo(CAR_WIDTH/4 - 3, -CAR_HEIGHT/2 + 5);
            ctx.closePath();
            ctx.fill();

            // Side windows - Left side
            // Front door window
            ctx.beginPath();
            ctx.moveTo(-CAR_WIDTH/4, -CAR_HEIGHT/2);
            ctx.lineTo(0, -CAR_HEIGHT/2);
            ctx.lineTo(0 - 3, -CAR_HEIGHT/2 + 3);
            ctx.lineTo(-CAR_WIDTH/4 + 3, -CAR_HEIGHT/2 + 3);
            ctx.closePath();
            ctx.fill();

            // Back door window
            ctx.beginPath();
            ctx.moveTo(0, -CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4, -CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4 - 3, -CAR_HEIGHT/2 + 3);
            ctx.lineTo(0 - 3, -CAR_HEIGHT/2 + 3);
            ctx.closePath();
            ctx.fill();

            // Side windows - Right side
            // Front door window
            ctx.beginPath();
            ctx.moveTo(-CAR_WIDTH/4, CAR_HEIGHT/2);
            ctx.lineTo(0, CAR_HEIGHT/2);
            ctx.lineTo(0 - 3, CAR_HEIGHT/2 - 3);
            ctx.lineTo(-CAR_WIDTH/4 + 3, CAR_HEIGHT/2 - 3);
            ctx.closePath();
            ctx.fill();

            // Back door window
            ctx.beginPath();
            ctx.moveTo(0, CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4, CAR_HEIGHT/2);
            ctx.lineTo(CAR_WIDTH/4 - 3, CAR_HEIGHT/2 - 3);
            ctx.lineTo(0 - 3, CAR_HEIGHT/2 - 3);
            ctx.closePath();
            ctx.fill();

            // Draw headlights
            ctx.fillStyle = '#FFF';
            ctx.fillRect(CAR_WIDTH/2 - 2, -CAR_HEIGHT/2 + 1, 3, 5);    // Left headlight
            ctx.fillRect(CAR_WIDTH/2 - 2, CAR_HEIGHT/2 - 6, 3, 5);  // Right headlight

            ctx.restore();
        }

        function smoothPath(path) {
            if (path.length < 3) return path;
            
            const smoothed = [];
            const halfWindow = Math.floor(SMOOTHING_WINDOW / 2);
            
            for (let i = 0; i < path.length; i++) {
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                
                // Calculate weighted average of surrounding points
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < path.length) {
                        // Use triangular weighting (points closer have more influence)
                        const weight = 1 - Math.abs(j) / (halfWindow + 1);
                        sumX += path[idx].x * weight;
                        sumY += path[idx].y * weight;
                        count += weight;
                    }
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }

        function handleP1Done() {
             if (player1Path.length < 2) {
                 statusDiv.textContent = "Pelaaja 1: Polku on liian lyhyt! Piirrä pitempi polku.";
                 return;
             }

             gameState = 'P2_WAITING';
             isDrawing = false;
             doneButton.style.display = 'none';
             resetButton.style.display = 'inline-block';
             statusDiv.textContent = 'Pelaaja 2: Seuraa polkua harmaasta ympyrästä alkaen.';

            player1TotalLength = calculatePathLength(player1Path);
            const markerRadius = P1_WIDTH / 2 * MARKER_RADIUS_FACTOR;
             startMarker = { ...player1Path[0], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };
             endMarker = { ...player1Path[player1Path.length - 1], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };

             // Create smoothed path for car to follow
             smoothedPath = smoothPath(player1Path);

             // Calculate progress markers
             progressMarkers = [];
             for (let i = 0; i <= 10; i++) { // 10 segments (0% to 100%)
                 const targetProgress = i * PROGRESS_INTERVAL;
                 let accumulatedLength = 0;
                 let markerPoint = null;
                 let markerDirection = null;

                 for (let j = 0; j < smoothedPath.length - 1; j++) {
                     const segmentLength = dist(smoothedPath[j], smoothedPath[j + 1]);
                     if (accumulatedLength + segmentLength >= targetProgress * player1TotalLength) {
                         const t = (targetProgress * player1TotalLength - accumulatedLength) / segmentLength;
                         markerPoint = {
                             x: smoothedPath[j].x + t * (smoothedPath[j + 1].x - smoothedPath[j].x),
                             y: smoothedPath[j].y + t * (smoothedPath[j + 1].y - smoothedPath[j].y)
                         };
                         markerDirection = {
                             x: smoothedPath[j + 1].x - smoothedPath[j].x,
                             y: smoothedPath[j + 1].y - smoothedPath[j].y
                         };
                         // Normalize direction
                         const length = Math.sqrt(markerDirection.x * markerDirection.x + markerDirection.y * markerDirection.y);
                         markerDirection.x /= length;
                         markerDirection.y /= length;
                         break;
                     }
                     accumulatedLength += segmentLength;
                 }

                 if (markerPoint && markerDirection) {
                     progressMarkers.push({ point: markerPoint, direction: markerDirection });
                 }
             }

             redrawAll();
        }

        function getPointAlongPath(progress, path) {
            if (path.length < 2) return path[0];
            
            // Use smoothed path for car movement
            const targetPath = path === player1Path ? smoothedPath : path;
            if (!targetPath || targetPath.length < 2) return path[0];
            
            let accumulatedLength = 0;
            for (let i = 0; i < targetPath.length - 1; i++) {
                const segmentLength = dist(targetPath[i], targetPath[i + 1]);
                if (accumulatedLength + segmentLength >= progress * player1TotalLength) {
                    const t = (progress * player1TotalLength - accumulatedLength) / segmentLength;
                    return {
                        x: targetPath[i].x + t * (targetPath[i + 1].x - targetPath[i].x),
                        y: targetPath[i].y + t * (targetPath[i + 1].y - targetPath[i].y)
                    };
                }
                accumulatedLength += segmentLength;
            }
            return targetPath[targetPath.length - 1];
        }

        function getDirectionAlongPath(progress, path) {
            if (path.length < 2) return { x: 0, y: 0 };
            
            // Use smoothed path for car movement
            const targetPath = path === player1Path ? smoothedPath : path;
            if (!targetPath || targetPath.length < 2) return { x: 0, y: 0 };
            
            let accumulatedLength = 0;
            for (let i = 0; i < targetPath.length - 1; i++) {
                const segmentLength = dist(targetPath[i], targetPath[i + 1]);
                if (accumulatedLength + segmentLength >= progress * player1TotalLength) {
                    const t = (progress * player1TotalLength - accumulatedLength) / segmentLength;
                    const direction = {
                        x: targetPath[i + 1].x - targetPath[i].x,
                        y: targetPath[i + 1].y - targetPath[i].y
                    };
                    // Normalize direction
                    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                    return {
                        x: direction.x / length,
                        y: direction.y / length
                    };
                }
                accumulatedLength += segmentLength;
            }
            return { x: 0, y: 0 };
        }

        function animateCar() {
            if (carProgress >= 1) {
                gameState = 'P2_FINISHED';
                if (carAnimationFrame) {
                    cancelAnimationFrame(carAnimationFrame);
                }
                // Stop engine sound immediately
                if (engineSound) {
                    engineSound.mainOsc.stop();
                    engineSound.varOsc.stop();
                    engineSound = null;
                }
                // Play a victory honk pattern: short-short-long
                playHonk([0.1, 0.6], [0.1]);
                return;
            }

            // Calculate current and upcoming curvature
            const currentCurvature = calculateCurvature(carProgress, player1Path);
            const upcomingProgress = Math.min(1, carProgress + CURVE_LOOK_AHEAD);
            const upcomingCurvature = calculateCurvature(upcomingProgress, player1Path);

            // Calculate target speed based on current curvature
            const targetSpeedMultiplier = getSpeedMultiplier(currentCurvature);
            let targetSpeed = CAR_PIXEL_SPEED * targetSpeedMultiplier;

            // Apply finish line deceleration
            const distanceToFinish = 1 - carProgress;
            if (distanceToFinish < FINISH_PREPARATION_DISTANCE) {
                const finishFactor = distanceToFinish / FINISH_PREPARATION_DISTANCE;
                const minSpeed = CAR_PIXEL_SPEED * MIN_FINISH_SPEED;
                targetSpeed = minSpeed + (targetSpeed - minSpeed) * finishFactor;
            }

            // Get dynamic deceleration rate based on upcoming curves
            const decelerationRate = getDecelerationRate(currentCurvature, upcomingCurvature);

            // Gradually adjust current speed towards target speed
            if (targetSpeed > currentSpeed) {
                // Accelerate with a rate that depends on how far we are from target speed
                const speedDiff = targetSpeed - currentSpeed;
                const accelerationRate = ACCELERATION_RATE * (1 + speedDiff / CAR_PIXEL_SPEED); // Faster acceleration when far from target
                currentSpeed = Math.min(targetSpeed, currentSpeed + CAR_PIXEL_SPEED * accelerationRate);
            } else {
                // Decelerate with dynamic rate
                currentSpeed = Math.max(targetSpeed, currentSpeed - CAR_PIXEL_SPEED * decelerationRate);
            }

            // Calculate the next position based on current speed
            const currentPos = getPointAlongPath(carProgress, player1Path);
            const nextProgress = carProgress + (currentSpeed / player1TotalLength);
            const nextPos = getPointAlongPath(nextProgress, player1Path);
            
            // Update car position and progress
            carPosition = nextPos;
            carProgress = nextProgress;
            
            const direction = getDirectionAlongPath(carProgress, player1Path);
            const targetCarAngle = Math.atan2(direction.y, direction.x);
            
            // Calculate angle change
            const angleDiff = targetCarAngle - currentCarAngle;
            const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
            
            // Handle sound effects based on turning
            const currentTime = Date.now();
            if (Math.abs(normalizedDiff) > TURN_THRESHOLD && currentTime - lastAngleChange > SOUND_COOLDOWN) {
                playSound('screech');
                lastAngleChange = currentTime;
            }
            
            // Update car angle
            currentCarAngle += normalizedDiff * CAR_TURN_SPEED;
            
            // Start engine sound if not already playing
            if (!engineSound) {
                engineSound = playSound('engine');
            } else {
                // Update engine sound based on current speed
                engineSound.updateSpeed(currentSpeed);
            }
            
            redrawAll();
            drawCar(carPosition, currentCarAngle);

            carAnimationFrame = requestAnimationFrame(animateCar);
        }

        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Player 1 path components if available
            if (startMarker && endMarker) {
                drawCircle(startMarker, startMarker.radius, START_COLOR);
                drawCircle(endMarker, endMarker.radius, END_COLOR);
                drawPath(player1Path, P1_COLOR, P1_WIDTH, false);
                
                // Draw progress markers, skipping the first and last markers
                progressMarkers.slice(1, -1).forEach(marker => {
                    drawDirectionalMarker(marker.point, marker.direction);
                });
            } else if (player1Path.length > 0) {
                // Draw P1 path with isDrawing flag based on game state
                drawPath(player1Path, P1_COLOR, P1_WIDTH, gameState === 'P1_DRAWING');
            }

            // Draw Player 2 path if they are drawing or failed
            if (gameState === 'P2_DRAWING' || gameState === 'P2_WAITING') {
                drawPath(player2Path, P2_COLOR, P2_WIDTH, false);
            }
        }

        // --- Game Logic ---
        function resetPlayer2() {
            player2Path = [];
            isDrawing = false;
            lastPlayedProgressMilestone = 0;
            currentActiveSegmentIndex = 0; // Reset the active segment index
            gameState = 'P2_WAITING';
            statusDiv.textContent = 'Pelaaja 2: Seuraa polkua harmaasta ympyrästä alkaen.';
            redrawAll();
        }

        function resetGame() {
            gameState = 'P1_DRAWING';
            player1Path = [];
            smoothedPath = []; // Clear smoothed path
            player2Path = [];
            isDrawing = false;
            player1TotalLength = 0;
            lastPlayedProgressMilestone = 0;
            startMarker = null;
            endMarker = null;
            progressMarkers = []; // Clear progress markers
            doneButton.style.display = 'inline-block';
            resetButton.style.display = 'none';
            statusDiv.textContent = 'Pelaaja 1: Piirrä polku.';
            
            // Reset car state
            if (carAnimationFrame) {
                cancelAnimationFrame(carAnimationFrame);
                carAnimationFrame = null;
            }
            carProgress = 0;
            carPosition = { x: 0, y: 0 };
            carAngle = 0;
            
            // Stop engine sound if playing
            if (engineSound) {
                engineSound.mainOsc.stop();
                engineSound.varOsc.stop();
                engineSound = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // --- Event Handlers ---
        function handleStart(e) {
             if (e.touches && e.touches.length > 1) return;
             e.preventDefault();
             hasInteracted = true;
             initAudio();

             const pos = getEventCoords(e);

             if (gameState === 'P1_DRAWING') {
                 isDrawing = true;
                 player1Path = [pos];
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
             } else if (gameState === 'P2_WAITING') {
                 if (startMarker && dist(pos, startMarker) <= startMarker.snapRadius) {
                     isDrawing = true;
                     player2Path = [pos];
                     lastPlayedProgressMilestone = 0;
                     gameState = 'P2_DRAWING';
                     statusDiv.textContent = 'Pelaaja 2: Seuraa polkua! Pysy sinisen viivan sisällä!';
                     redrawAll();
                     drawPath(player2Path, P2_COLOR, P2_WIDTH, false);
                 } else {
                    statusDiv.textContent = 'Pelaaja 2: Aloita piirtäminen harmaasta ympyrästä!';
                 }
             }
        }

        function handleMove(e) {
            if (!isDrawing || (e.touches && e.touches.length > 1)) return;
            e.preventDefault();

            const pos = getEventCoords(e);
            const lastPos = (gameState === 'P1_DRAWING' ? player1Path : player2Path).slice(-1)[0];

            if (pos.x === lastPos.x && pos.y === lastPos.y) return;

            if (gameState === 'P1_DRAWING') {
                player1Path.push(pos);
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = P1_COLOR;
                ctx.lineWidth = P1_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();

            } else if (gameState === 'P2_DRAWING') {
                const threshold = P1_WIDTH / 2 * HIT_THRESHOLD_FACTOR;
                if (!isPointWithinPath(pos, player1Path, threshold)) {
                    playSound('alarm');
                    resetPlayer2();
                    statusDiv.textContent = 'Pelaaja 2: Hups! Eksyit polulta! Aloita uudelleen alusta.';
                } else {
                    player2Path.push(pos);
                    ctx.beginPath();
                    ctx.moveTo(lastPos.x, lastPos.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = P2_COLOR;
                    ctx.lineWidth = P2_WIDTH;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    const currentProgress = getProgressAlongPath(pos, player1Path);
                    const currentMilestone = Math.floor(currentProgress / PROGRESS_INTERVAL);

                    if (currentMilestone > lastPlayedProgressMilestone && currentProgress < 1.0) {
                         lastPlayedProgressMilestone = currentMilestone;
                         playSound('chime', currentProgress);
                    }
                }
            }
        }

        function handleEnd(e) {
            if (!isDrawing) return;
            if (e.touches && e.touches.length > 0) return;
            e.preventDefault();

            if (gameState === 'P1_DRAWING') {
                isDrawing = false;
                if (player1Path.length < 2) {
                    statusDiv.textContent = "Pelaaja 1: Polku on liian lyhyt! Piirrä pitempi polku.";
                } else {
                    statusDiv.textContent = "Pelaaja 1: Paina 'Valmis' tai jatka piirtämistä.";
                }
            } else if (gameState === 'P2_DRAWING') {
                const lastPos = player2Path.slice(-1)[0];
                isDrawing = false;

                if (endMarker && dist(lastPos, endMarker) <= endMarker.snapRadius) {
                    const finalProgress = getProgressAlongPath(lastPos, player1Path);
                    if (finalProgress >= 0.95) {
                        gameState = 'CAR_ANIMATING';
                        statusDiv.textContent = 'Pelaaja 2 Voitti! Hienosti piirretty! 🎉';
                        playSound('success');
                        redrawAll();
                        drawPath(player2Path, P2_COLOR, P2_WIDTH, false);
                        
                        // Reset car state and start animation
                        carProgress = 0;
                        carPosition = { ...player1Path[0] };
                        carAngle = 0;
                        animateCar();
                    } else {
                        playSound('alarm');
                        resetPlayer2();
                        statusDiv.textContent = 'Pelaaja 2: Saavutit maalin liian aikaisin! Aloita uudelleen alusta.';
                    }
                } else {
                    playSound('alarm');
                    resetPlayer2();
                    statusDiv.textContent = 'Pelaaja 2: Piirtäminen keskeytyi! Aloita uudelleen alusta.';
                }
            }
        }


        // --- Initialization ---
        function resizeCanvas() {
            const controlsHeight = document.getElementById('controls').offsetHeight + 20; // Get actual height + margin
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight; // Adjust if controls overlay canvas significantly

             // Style setting needed if CSS dimensions are different
             canvas.style.width = `${window.innerWidth}px`;
             canvas.style.height = `${window.innerHeight}px`;

             redrawAll(); // Redraw contents after resize
        }

        // Setup Event Listeners
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseout', handleEnd); // Treat leaving canvas like mouseup

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false }); // Treat cancel like end

        doneButton.addEventListener('click', handleP1Done);
        resetButton.addEventListener('click', resetGame);

        // Add width slider event listener
        const widthSlider = document.getElementById('widthSlider');
        const widthValue = document.getElementById('widthValue');
        widthSlider.addEventListener('input', (e) => {
            P1_WIDTH = parseInt(e.target.value);
            widthValue.textContent = P1_WIDTH;
            if (gameState === 'P1_DRAWING' && player1Path.length > 0) {
                redrawAll();
            }
        });

        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        resizeCanvas();
        resetGame(); // Initialize game state

    </script>
</body>
</html>
