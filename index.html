<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Polkua Pitkin Peli</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0f0f0; touch-action: none; }
        canvas { display: block; background-color: #ffffff; cursor: crosshair; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #doneButton, #resetButton, #saveP1CourseButton {
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s, opacity 0.3s;
        }
        #saveP1CourseButton {
            background-color: #007bff;
        }
        #saveP1CourseButton:hover {
            background-color: #0056b3;
        }
        #saveP1CourseButton:disabled {
            opacity: 0.7;
            cursor: default;
        }
        #doneButton:hover, #resetButton:hover {
            background-color: #45a049;
        }
        #status {
            font-weight: bold;
            color: #333;
        }
        .width-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #widthSlider {
            width: 100px;
        }
        #widthValue {
            min-width: 40px;
            text-align: right;
        }
        /* Game screen styles */
        .game-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }
        
        .game-screen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .game-screen h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 15px;
        }
        
        .game-screen p {
            color: white;
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        #victoryScreen {
            color: #4CAF50;
        }
        
        #defeatScreen {
            color: #FF4444;
        }
        
        .game-screen-buttons {
            display: flex;
            gap: 20px;
            pointer-events: auto; /* Re-enable clicks for buttons */
        }
        
        .game-button {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
            font-weight: bold;
            min-width: 200px;
        }
        
        .replay-button {
            background-color: #4CAF50;
            color: white;
        }
        
        .replay-button:hover {
            background-color: #45a049;
        }
        
        .new-game-button {
            background-color: #2196F3;
            color: white;
        }
        
        .new-game-button:hover {
            background-color: #0b7dda;
        }

        /* Add Saved Courses Button */
        .top-right-button {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .top-right-button:hover {
            background-color: #0056b3;
        }

        /* Add Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            height: 100%;
            width: 280px; /* Adjust width as needed */
            background-color: rgba(240, 240, 240, 0.95);
            box-shadow: -2px 0 5px rgba(0,0,0,0.2);
            transform: translateX(100%); /* Start hidden off-screen */
            transition: transform 0.3s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }
        .sidebar.right {
            right: 0;
            transform: translateX(100%);
        }
        .sidebar.visible {
            transform: translateX(0);
        }
        .sidebar h2 {
            color: #333;
            text-align: center;
            padding: 15px;
            margin: 0;
            border-bottom: 1px solid #ccc;
            font-size: 1.4em;
        }
        .close-button {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            font-size: 2em;
            cursor: pointer;
            color: #666;
        }
        .close-button:hover {
            color: #000;
        }
        .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Spacing between thumbnails */
        }
        .thumbnail-container {
            border: 1px solid #ccc;
            background-color: white;
            padding: 5px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center canvas */
            position: relative; /* For positioning stars */
            transition: box-shadow 0.2s;
        }
        .thumbnail-container:active {
            cursor: grabbing;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .thumbnail-canvas {
            width: 240px; /* Adjust as needed */
            height: 150px; /* Adjust as needed */
            display: block;
            background-color: #e9f5ff; /* Light blue background */
            margin-bottom: 5px; /* Space before stars */
        }
        .thumbnail-stars {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 1.1em;
            color: gold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
        }

        .trash-can {
            position: fixed;
            bottom: 20px;
            left: 20px; /* Position relative to viewport */
            z-index: 102; /* Above sidebar potentially */
            font-size: 3em;
            padding: 15px;
            background-color: rgba(255, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            cursor: default;
            transition: background-color 0.3s, transform 0.3s;
            display: none; /* Hidden by default */
        }
        .trash-can.active-drop {
            background-color: rgba(255, 0, 0, 0.9);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="doneButton">Valmis!</button>
        <button id="saveP1CourseButton">Tallenna rata</button> <!-- Ensure this has NO display:none -->
        <button id="resetButton" style="display: none;">Uusi Peli</button> <!-- Keep this hidden -->
        <div class="width-control">
            <label for="widthSlider">Polun leveys:</label>
            <input type="range" id="widthSlider" min="20" max="60" value="40">
            <span id="widthValue">40</span>
        </div>
        <div id="status">Pelaaja 1: Piirr√§ polku.</div>
    </div>

    <!-- Add Saved Courses Button -->
    <button id="savedCoursesButton" class="top-right-button">Tallennetut Polut</button> <!-- Ensure this has NO display:none -->

    <!-- Add Sidebar -->
    <div id="savedCoursesSidebar" class="sidebar right">
        <button id="closeSidebarButton" class="close-button">&times;</button>
        <h2>Tallennetut Radat</h2>
        <div id="sidebarContent" class="sidebar-content">
            <!-- Thumbnails will be added here -->
        </div>
    </div>

    <!-- Add Trashcan -->
    <div id="trashCan" class="trash-can" style="display: none;">
        üóëÔ∏è
    </div>

    <!-- Victory screen -->
    <div id="victoryScreen" class="game-screen">
        <h1>P√§√§sit Maaliin!</h1>
        <h2 id="scoreDisplay">Pisteet: 0</h2>
        <p id="scoreMessage">Hyvin pelattu!</p>
        <p id="newRecordMessage" style="color: yellow; font-weight: bold; display: none;">Teit uuden enn√§tyksen!</p>
        <div class="game-screen-buttons">
            <button id="victoryReplayButton" class="game-button replay-button">Yrit√§ Uudelleen <span class="emoji">üöó</span></button>
            <button id="victoryNewGameButton" class="game-button new-game-button">Luo Uusi Peli <span class="emoji">üõ£Ô∏è</span></button>
            <button id="saveCourseButton">Tallenna rata</button>
        </div>
    </div>
    
    <!-- Defeat screen -->
    <div id="defeatScreen" class="game-screen">
        <h1>POLTTOAINE LOPPUI!</h1>
        <p>Yrit√§ p√§√§st√§ perille v√§hemmill√§ mutkilla</p>
        <div class="game-screen-buttons">
            <button id="defeatReplayButton" class="game-button replay-button">Yrit√§ Uudelleen <span class="emoji">üöó</span></button>
            <button id="defeatNewGameButton" class="game-button new-game-button">Luo Uusi Peli <span class="emoji">üõ£Ô∏è</span></button>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <script type="module">
        import { drawCar, CAR_CONSTANTS, createCar } from './src/car.js';
        import { playSound, playHonk, setHasInteracted } from './src/audio.js';
        import { generateDecorationsForPath } from './src/decoration.js';
        import { createCrashEffect, createVictoryCelebration, updateAndDrawParticles } from './src/effects.js';
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const doneButton = document.getElementById('doneButton');
        const resetButton = document.getElementById('resetButton');
        const statusDiv = document.getElementById('status');
        const savedCoursesButton = document.getElementById('savedCoursesButton'); // New button
        const savedCoursesSidebar = document.getElementById('savedCoursesSidebar'); // New sidebar
        const sidebarContent = document.getElementById('sidebarContent'); // Sidebar content area
        const closeSidebarButton = document.getElementById('closeSidebarButton'); // Close button
        const trashCan = document.getElementById('trashCan'); // Trashcan element
        const saveP1CourseButton = document.getElementById('saveP1CourseButton'); // Get reference to the new button

        // --- Constants ---
        const P1_COLOR = 'lightblue';
        let P1_WIDTH = 40;
        const P2_COLOR = 'black';
        const P2_WIDTH = 3;
        const START_COLOR = 'gray';
        const END_COLOR = 'green';
        const MARKER_RADIUS_FACTOR = 1.4;
        const HIT_THRESHOLD_FACTOR = 1.1;
        const PROGRESS_INTERVAL = 0.10;
        const START_END_SNAP_RADIUS_FACTOR = 1.5;
        const SCORE_THRESHOLD = 20;
        const SCORE_POINTS = 100;
        const MAX_PATH_LENGTH_FACTOR = 1.20;
        const THUMBNAIL_WIDTH = 240;
        const THUMBNAIL_HEIGHT = 150;
        const THUMBNAIL_PADDING = 10; // Padding inside thumbnail canvas

        // Car constants
        const CAR_PIXEL_SPEED = 2;
        const CAR_ANIMATION_INTERVAL = 16;
        const SMOOTHING_WINDOW = 10;
        const CURVATURE_WINDOW = 10;
        const MAX_CURVATURE = 0.9;
        const ACCELERATION_RATE = 0.005;
        const BASE_DECELERATION_RATE = 0.8;
        const CURVE_LOOK_AHEAD = 0.15;
        const MAX_DECELERATION_RATE = 1.2;
        const CURVE_PREPARATION_DISTANCE = 0.1;
        const FINISH_PREPARATION_DISTANCE = 0.2;
        const MIN_FINISH_SPEED = 0.3;
        const WHEEL_TURN_SPEED = 0.15;
        const CAR_TURN_SPEED = 0.1;
        const MAX_WHEEL_ANGLE = Math.PI / 4;

        // --- State ---
        let gameState = 'P1_DRAWING';
        let player1Path = [];
        let smoothedPath = [];
        let player2Path = [];
        let isDrawing = false;
        let player1TotalLength = 0;
        let lastPlayedProgressMilestone = 0;
        let startMarker = null;
        let endMarker = null;
        let progressMarkers = [];
        let currentActiveSegmentIndex = 0;
        let maxAllowedPathLength = 0;
        let currentPathLength = 0;
        let fuelConsumed = 0;
        let previousCarPosition = null;
        let defeatFlagged = false;
        let decorations = [];
        let tireMarks = [];
        // Add these state variables for session high score tracking
        let currentSessionHighScore = 0;
        let currentSessionBestPlayer2Path = [];
        let draggedCourseId = null; // Track the ID of the course being dragged
        let isFinishing = false; // Flag for the 1-second delay at the finish
        let activeParticles = []; // Array to store active emoji particles

        // Car state
        let carProgress = 0;
        let carAnimationFrame = null;
        let carPosition = { x: 0, y: 0 };
        let carAngle = 0;
        let currentWheelAngle = 0;
        let currentCarAngle = 0;
        let currentSpeed = 0;
        let carTrail = [];
        let engineSound = null;
        let lastAngleChange = 0;
        let carConfig = null;  // Add car configuration state
        let previousCarAngle = 0; // <--- Add state for previous car angle
        let isScreeching = false; // <--- Add state for current screech status
        const TURN_THRESHOLD = 0.5;
        const SOUND_COOLDOWN = 500; // We might not need SOUND_COOLDOWN anymore

        // Add this after the other animation frame variables
        let particleAnimationFrame = null;

        // --- Helper Functions ---
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            const touch = e.touches && e.touches[0];
            x = (touch ? touch.clientX : e.clientX) - rect.left;
            y = (touch ? touch.clientY : e.clientY) - rect.top;
            x *= canvas.width / rect.width;
            y *= canvas.height / rect.height;
            return { x, y };
        }

        function distSq(p1, p2) {
            return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        }

        function dist(p1, p2) {
            return Math.sqrt(distSq(p1, p2));
        }

        function pointLineSegmentDistance(p, a, b) {
            const l2 = distSq(a, b);
            if (l2 === 0) return dist(p, a);
            let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
            return dist(p, projection);
        }

        // New helper function to find the closest point on a path
        function findClosestPointOnPath(point, path) {
            if (!path || path.length < 1) return null;
            if (path.length === 1) return { ...path[0] };

            let minDistanceSq = Infinity;
            let closestPoint = null;

            for (let i = 0; i < path.length - 1; i++) {
                const a = path[i];
                const b = path[i + 1];
                const l2 = distSq(a, b);
                let projection;
                let dSq;

                if (l2 === 0) { // Segment is a point
                    projection = a;
                    dSq = distSq(point, a);
                } else {
                    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    projection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                    dSq = distSq(point, projection);
                }

                if (dSq < minDistanceSq) {
                    minDistanceSq = dSq;
                    closestPoint = projection;
                }
            }
             // Check distance to the very last point
             const distToLastSq = distSq(point, path[path.length - 1]);
             if (distToLastSq < minDistanceSq) {
                 // minDistanceSq = distToLastSq; // Not needed, just update point
                 closestPoint = { ...path[path.length - 1] };
             }


            return closestPoint; // Returns the {x, y} of the closest point on the path centerline
        }

        function isPointWithinPath(point, path, threshold) {
            if (path.length < 2) return true; // Path is just a point or empty
            
            // For Player 1's drawing phase, use the original behavior
            if (gameState === 'P1_DRAWING') {
                let minDistance = Infinity;
                for (let i = 0; i < path.length - 1; i++) {
                    minDistance = Math.min(minDistance, pointLineSegmentDistance(point, path[i], path[i + 1]));
                }
                if (path.length > 0) {
                    minDistance = Math.min(minDistance, dist(point, path[0]));
                    minDistance = Math.min(minDistance, dist(point, path[path.length - 1]));
                }
                return minDistance <= threshold;
            }
            
            // For Player 2's drawing phase, check against all segments up to current position plus look-ahead
            const lookAheadSegments = 3; // Number of segments to look ahead
            const startIdx = 0; // Always start from beginning
            const endIdx = Math.min(currentActiveSegmentIndex + lookAheadSegments, path.length - 1);
            
            let minDistance = Infinity;
            for (let i = startIdx; i <= endIdx; i++) {
                if (i < path.length - 1) {
                    minDistance = Math.min(minDistance, pointLineSegmentDistance(point, path[i], path[i + 1]));
                }
            }
            
            // If we're near the end of the current segment, advance to the next one
            if (currentActiveSegmentIndex < path.length - 1) {
                const currentSegmentEnd = path[currentActiveSegmentIndex + 1];
                if (dist(point, currentSegmentEnd) <= threshold * 1.5) {
                    currentActiveSegmentIndex++;
                }
            }
            
            return minDistance <= threshold;
        }

        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                length += dist(path[i], path[i + 1]);
            }
            return length;
        }

        function getProgressAlongPath(point, path) {
            if (path.length < 2 || player1TotalLength === 0) return 0;

            // For Player 1's drawing phase, use the original behavior
            if (gameState === 'P1_DRAWING') {
                let minDistanceSq = Infinity;
                let lengthUpToProjection = 0;
                let accumulatedLength = 0;

                for (let i = 0; i < path.length - 1; i++) {
                    const a = path[i];
                    const b = path[i + 1];
                    const segmentLength = dist(a, b);
                    const l2 = distSq(a, b);
                    let currentProjection = a;
                    let t = 0;

                    if (l2 !== 0) {
                        t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        currentProjection = { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) };
                    }

                    const dSq = distSq(point, currentProjection);

                    if (dSq < minDistanceSq) {
                        minDistanceSq = dSq;
                        lengthUpToProjection = accumulatedLength + t * segmentLength;
                    }
                    accumulatedLength += segmentLength;
                }
                // Check distance to the last point as well
                const distToLastPointSq = distSq(point, path[path.length - 1]);
                if (distToLastPointSq < minDistanceSq) {
                    lengthUpToProjection = accumulatedLength;
                }

                return lengthUpToProjection / player1TotalLength;
            }

            // For Player 2's drawing phase, calculate progress based on current active segment
            let accumulatedLength = 0;
            let currentSegmentProgress = 0;

            // Calculate length up to current active segment
            for (let i = 0; i < currentActiveSegmentIndex; i++) {
                accumulatedLength += dist(path[i], path[i + 1]);
            }

            // Calculate progress within current segment
            if (currentActiveSegmentIndex < path.length - 1) {
                const currentStart = path[currentActiveSegmentIndex];
                const currentEnd = path[currentActiveSegmentIndex + 1];
                const segmentLength = dist(currentStart, currentEnd);
                const l2 = distSq(currentStart, currentEnd);
                
                if (l2 !== 0) {
                    const t = ((point.x - currentStart.x) * (currentEnd.x - currentStart.x) + 
                              (point.y - currentStart.y) * (currentEnd.y - currentStart.y)) / l2;
                    currentSegmentProgress = Math.max(0, Math.min(1, t)) * segmentLength;
                }
            }

            return (accumulatedLength + currentSegmentProgress) / player1TotalLength;
        }

        function calculateCurvature(progress, path) {
            if (path.length < 3) return 0;
            
            // Get points before and after current position
            const lookAhead = CURVATURE_WINDOW;
            const currentPoint = getPointAlongPath(progress, path);
            const prevPoint = getPointAlongPath(Math.max(0, progress - 0.01), path);
            const nextPoint = getPointAlongPath(Math.min(1, progress + 0.01), path);
            
            // Calculate vectors
            const v1 = { x: currentPoint.x - prevPoint.x, y: currentPoint.y - prevPoint.y };
            const v2 = { x: nextPoint.x - currentPoint.x, y: nextPoint.y - currentPoint.y };
            
            // Calculate angle between vectors
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            
            if (mag1 === 0 || mag2 === 0) return 0;
            
            const cosAngle = dot / (mag1 * mag2);
            // Clamp cosAngle to [-1, 1] to avoid floating point errors
            const clampedCos = Math.max(-1, Math.min(1, cosAngle));
            const angle = Math.acos(clampedCos);
            
            // Convert angle to curvature (0 to 1)
            // 0 = straight line, 1 = complete U-turn
            return Math.min(MAX_CURVATURE, angle / Math.PI);
        }

        function getSpeedMultiplier(curvature) {
            // Convert curvature (0 to MAX_CURVATURE) to speed multiplier (0.05 to 1.0)
            // Now at maximum curvature, speed will be reduced to 5% instead of 10%
            return 1.0 - (curvature / MAX_CURVATURE) * 0.95;
        }

        function getDecelerationRate(currentCurvature, upcomingCurvature) {
            // If there's a sharp curve coming up, decelerate more aggressively
            const curveFactor = Math.max(0, upcomingCurvature - currentCurvature);
            
            // Calculate how close we are to the curve
            const distanceToCurve = CURVE_LOOK_AHEAD - CURVE_PREPARATION_DISTANCE;
            const preparationFactor = Math.max(0, Math.min(1, distanceToCurve / CURVE_PREPARATION_DISTANCE));
            
            // Combine curve sharpness with preparation factor
            // Add extra deceleration for very sharp curves (curvature > 0.7)
            const extraSharpCurveFactor = Math.max(0, (upcomingCurvature - 0.7) / 0.2);
            const combinedFactor = (curveFactor + extraSharpCurveFactor) * preparationFactor;
            
            return BASE_DECELERATION_RATE + (combinedFactor * (MAX_DECELERATION_RATE - BASE_DECELERATION_RATE));
        }

        // --- Drawing Functions ---
         function drawPath(path, color, width, isDrawing = false) {
             if (path.length < 1) return;
             
             if (!isDrawing) {
                 // Draw the outline (black path with slightly larger width) only for completed paths
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = width + 4; // 2 pixels wider on each side
                 ctx.lineCap = 'round';
                 ctx.lineJoin = 'round';

                 ctx.beginPath();
                 ctx.moveTo(path[0].x, path[0].y);
                 for (let i = 1; i < path.length; i++) {
                     ctx.lineTo(path[i].x, path[i].y);
                 }
                 ctx.stroke();
             }

             // Draw the main colored path
             ctx.strokeStyle = color;
             ctx.lineWidth = width;
             ctx.lineCap = 'round';
             ctx.lineJoin = 'round';

             ctx.beginPath();
             ctx.moveTo(path[0].x, path[0].y);
             for (let i = 1; i < path.length; i++) {
                 ctx.lineTo(path[i].x, path[i].y);
             }
             ctx.stroke();

             // Draw the dashed guide line for Player 1's path on top of the main path
             if (!isDrawing && color === P1_COLOR) {
                 ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                 ctx.lineWidth = 1;
                 ctx.setLineDash([5, 5]); // Create dashed line pattern
                 ctx.lineCap = 'butt';
                 ctx.lineJoin = 'miter';
                 ctx.beginPath();
                 ctx.moveTo(path[0].x, path[0].y);
                 for (let i = 1; i < path.length; i++) {
                     ctx.lineTo(path[i].x, path[i].y);
                 }
                 ctx.stroke();
                 ctx.setLineDash([]); // Reset dash pattern
             }
         }

        function drawCircle(center, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDirectionalMarker(point, direction, color = 'rgba(0, 0, 0, 0.3)') {
            const arrowLength = P1_WIDTH * 0; // Length of the arrow
            const arrowWidth = P1_WIDTH * 0.2; // Reduced width of the arrow head for a thinner line
            
            ctx.save();
            ctx.translate(point.x, point.y);
            ctx.rotate(Math.atan2(direction.y, direction.x));
            
            // Draw arrow head as two lines
            ctx.beginPath();
            ctx.moveTo(arrowLength, 0);
            ctx.lineTo(arrowLength - arrowWidth, -arrowWidth / 2);
            ctx.moveTo(arrowLength, 0);
            ctx.lineTo(arrowLength - arrowWidth, arrowWidth / 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1; // Set a thin line width
            ctx.stroke();
            
            ctx.restore();
        }

        function smoothPath(path) {
            if (path.length < 3) return path;
            
            const smoothed = [];
            const halfWindow = Math.floor(SMOOTHING_WINDOW / 2);
            
            for (let i = 0; i < path.length; i++) {
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                
                // Calculate weighted average of surrounding points
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < path.length) {
                        // Use triangular weighting (points closer have more influence)
                        const weight = 1 - Math.abs(j) / (halfWindow + 1);
                        sumX += path[idx].x * weight;
                        sumY += path[idx].y * weight;
                        count += weight;
                    }
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }

        function handleP1Done() {
             if (player1Path.length < 2) {
                 statusDiv.textContent = "Pelaaja 1: Polku on liian lyhyt! Piirr√§ pitempi polku.";
                 return;
             }

             gameState = 'P2_WAITING';
             isDrawing = false;
             doneButton.style.display = 'none';
             saveP1CourseButton.style.display = 'none'; // Hide P1 save button
             resetButton.style.display = 'inline-block';
             savedCoursesButton.style.display = 'none'; // Hide saved courses list button
             statusDiv.textContent = 'Pelaaja 2: Seuraa polkua harmaasta ympyr√§st√§ alkaen.';

            player1TotalLength = calculatePathLength(player1Path);
            maxAllowedPathLength = player1TotalLength * MAX_PATH_LENGTH_FACTOR;
            currentPathLength = 0;
            const markerRadius = P1_WIDTH / 2 * MARKER_RADIUS_FACTOR;
             startMarker = { ...player1Path[0], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };
             endMarker = { ...player1Path[player1Path.length - 1], radius: markerRadius, snapRadius: markerRadius * START_END_SNAP_RADIUS_FACTOR };

             // Create smoothed path for car to follow -- **Ensure this represents the P1 path structure**
             // smoothedPath = smoothPath(player1Path); // Option 1: Use actual smoothed P1 path
             smoothedPath = player1Path; // Option 2: Use the raw P1 path (current implementation)
                                        // This is the path that will be hashed and saved. DO NOT MODIFY LATER.

             // Calculate progress markers based on the original player1Path length
             progressMarkers = [];
             for (let i = 0; i <= 10; i++) { // 10 segments (0% to 100%)
                 const targetProgress = i * PROGRESS_INTERVAL;
                 let accumulatedLength = 0;
                 let markerPoint = null;
                 let markerDirection = null;

                 for (let j = 0; j < player1Path.length - 1; j++) {
                     const segmentLength = dist(player1Path[j], player1Path[j + 1]);
                     if (accumulatedLength + segmentLength >= targetProgress * player1TotalLength) {
                         const t = (targetProgress * player1TotalLength - accumulatedLength) / segmentLength;
                         markerPoint = {
                             x: player1Path[j].x + t * (player1Path[j + 1].x - player1Path[j].x),
                             y: player1Path[j].y + t * (player1Path[j + 1].y - player1Path[j].y)
                         };
                         markerDirection = {
                             x: player1Path[j + 1].x - player1Path[j].x,
                             y: player1Path[j + 1].y - player1Path[j].y
                         };
                         // Normalize direction
                         const length = Math.sqrt(markerDirection.x * markerDirection.x + markerDirection.y * markerDirection.y);
                         markerDirection.x /= length;
                         markerDirection.y /= length;
                         break;
                     }
                     accumulatedLength += segmentLength;
                 }

                 if (markerPoint && markerDirection) {
                     progressMarkers.push({ point: markerPoint, direction: markerDirection });
                 }
             }

             // Generate decorations
             const decorationDensity = 5; // <-- INCREASED from 0.8. Try values like 5 or 10
             const decorationOffset = P1_WIDTH * 1.5; // Adjust offset based on path width
             decorations = generateDecorationsForPath(player1Path, decorationDensity, decorationOffset);

             redrawAll();
        }

        function getPointAlongPath(progress, path) {
            // Always calculate based on the specific 'path' provided
            if (!path || path.length < 2) return path[0] || {x: 0, y: 0}; // Handle empty or single-point path

            // Calculate total length of the *provided* path for accurate progress mapping
            let pathTotalLength = calculatePathLength(path);
            if (pathTotalLength === 0) return path[0]; // Avoid division by zero

            let targetDistance = progress * pathTotalLength;
            let accumulatedLength = 0;

            for (let i = 0; i < path.length - 1; i++) {
                const segmentLength = dist(path[i], path[i + 1]);
                if (accumulatedLength + segmentLength >= targetDistance || i === path.length - 2) {
                    // If segmentLength is 0, t calculation fails, return start point of segment
                    if (segmentLength === 0) return path[i];
                    // Ensure progress doesn't exceed 1 due to float precision
                    const clampedTarget = Math.min(targetDistance, pathTotalLength);
                    const t = (clampedTarget - accumulatedLength) / segmentLength;
                    // Clamp t between 0 and 1
                    const clampedT = Math.max(0, Math.min(1, t));
                    return {
                        x: path[i].x + clampedT * (path[i + 1].x - path[i].x),
                        y: path[i].y + clampedT * (path[i + 1].y - path[i].y)
                    };
                }
                accumulatedLength += segmentLength;
            }
            // Fallback: return the last point if progress is 1 or more
            return path[path.length - 1];
        }

        function getDirectionAlongPath(progress, path) {
            // Always calculate based on the specific 'path' provided
            if (!path || path.length < 2) return { x: 1, y: 0 }; // Default direction if path is too short

            // Calculate total length of the *provided* path
            let pathTotalLength = calculatePathLength(path);
            if (pathTotalLength === 0) return { x: 1, y: 0 }; // Default direction

            let targetDistance = progress * pathTotalLength;
            let accumulatedLength = 0;

            for (let i = 0; i < path.length - 1; i++) {
                const segmentLength = dist(path[i], path[i + 1]);
                // Find the segment where the progress point lies
                if (accumulatedLength + segmentLength >= targetDistance || i === path.length - 2) {
                    const direction = {
                        x: path[i + 1].x - path[i].x,
                        y: path[i + 1].y - path[i].y
                    };
                    // Normalize direction
                    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                    // If segment length is zero, try the next segment or return default
                    if (length === 0) {
                        if (i < path.length - 2) continue; // Try next segment if possible
                        else return { x: 1, y: 0 }; // Default at the very end
                    }
                    return {
                        x: direction.x / length,
                        y: direction.y / length
                    };
                }
                accumulatedLength += segmentLength;
            }
            // Fallback: return direction of the last segment or default
             if (path.length >= 2) {
                 const lastSegmentDirection = {
                     x: path[path.length - 1].x - path[path.length - 2].x,
                     y: path[path.length - 1].y - path[path.length - 2].y
                 };
                 const length = Math.sqrt(lastSegmentDirection.x * lastSegmentDirection.x + lastSegmentDirection.y * lastSegmentDirection.y);
                 if (length > 0) {
                     return { x: lastSegmentDirection.x / length, y: lastSegmentDirection.y / length };
                 }
             }
            return { x: 1, y: 0 }; // Absolute fallback
        }

        function showVictoryScreen(score) {
            const victoryScreen = document.getElementById('victoryScreen');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const scoreMessage = document.getElementById('scoreMessage');
            const saveButton = document.getElementById('saveCourseButton');
            const newRecordMsg = document.getElementById('newRecordMessage');

            // Store the high score *before* this run
            const previousSessionHighScore = currentSessionHighScore;
            let newRecordSet = false;

            // Update session high score if this run was better *for the session*
            if (score > currentSessionHighScore) {
                currentSessionHighScore = score;
                currentSessionBestPlayer2Path = [...player2Path];
                console.log(`New session high score for this path: ${currentSessionHighScore}`);
                if (score > previousSessionHighScore) {
                    newRecordSet = true;
                }
            }

            // Update display content
            scoreDisplay.textContent = `Pisteet: ${score}`;
            scoreMessage.textContent = getScoreMessage(score);
            newRecordMsg.style.display = newRecordSet ? 'block' : 'none';
            saveButton.style.display = 'none';

            // Show the screen
            victoryScreen.style.display = 'flex';
        }

        function drawFailState() {
            const defeatScreen = document.getElementById('defeatScreen');
            defeatScreen.style.display = 'flex';
        }

        function drawFuelGauge() {
            // Only draw if P2 is drawing or car is animating
            if (gameState !== 'P2_DRAWING' && gameState !== 'CAR_ANIMATING') return;

            const gaugeWidth = 200;
            const gaugeHeight = 30;
            const x = canvas.width - gaugeWidth - 20;
            const y = 20;

            ctx.save();

            // Draw background
            ctx.beginPath();
            ctx.roundRect(x, y, gaugeWidth, gaugeHeight, 5);
            ctx.fillStyle = '#ddd';
            ctx.fill();

            // Calculate remaining fuel percentage
            let remainingFuel;
            if (gameState === 'CAR_ANIMATING') {
                // Use actual fuel consumed during animation
                if (defeatFlagged) {
                    remainingFuel = Math.max(0, 1 - (fuelConsumed * MAX_PATH_LENGTH_FACTOR / maxAllowedPathLength));
                } else {
                    remainingFuel = Math.max(0, 1 - (fuelConsumed / maxAllowedPathLength));
                }
            } else { // gameState === 'P2_DRAWING'
                // Use path length drawn so far
                remainingFuel = Math.max(0, 1 - (currentPathLength / maxAllowedPathLength));
            }

            // Draw fuel level
            const gradient = ctx.createLinearGradient(x, y, x + gaugeWidth, y);
            if (remainingFuel > 0.3) {
                gradient.addColorStop(0, '#4CAF50'); gradient.addColorStop(1, '#45a049');
            } else if (remainingFuel > 0.1) {
                gradient.addColorStop(0, '#FFA500'); gradient.addColorStop(1, '#FF8C00');
            } else {
                gradient.addColorStop(0, '#FF4444'); gradient.addColorStop(1, '#CC0000');
            }

            ctx.fillStyle = gradient;
            ctx.beginPath();
            // Ensure fuel bar doesn't go beyond gauge boundaries and handles 0 fuel correctly
            const fuelWidth = Math.max(0, Math.min(gaugeWidth, gaugeWidth * remainingFuel));
            // Need to draw a rectangle from the start, not a rounded one if width is small, or handle corners
            if (fuelWidth > 0) {
                ctx.roundRect(x, y, fuelWidth, gaugeHeight, 5);
                ctx.fill();
            }

            // Draw gauge border using the same path
            ctx.beginPath(); // Start new path for border
            ctx.roundRect(x, y, gaugeWidth, gaugeHeight, 5);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.stroke(); // Apply stroke to the border path

            // Draw fuel text
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.fillText(`Polttoaine: ${Math.round(remainingFuel * 100)}%`, x + gaugeWidth/2, y + gaugeHeight/2);

            ctx.restore(); // Restores shadow settings etc.
        }

        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw base P1 path elements (always behind everything else)
            if (startMarker && endMarker) {
                drawPath(player1Path, P1_COLOR, P1_WIDTH, false);
                drawCircle(startMarker, startMarker.radius, START_COLOR);
                drawCircle(endMarker, endMarker.radius, END_COLOR);
                progressMarkers.slice(1, -1).forEach(marker => {
                    drawDirectionalMarker(marker.point, marker.direction);
                });
            } else if (player1Path.length > 0) {
                 drawPath(player1Path, P1_COLOR, P1_WIDTH, gameState === 'P1_DRAWING');
            }

            // 2. Draw the car trail if animating or finished (behind decorations and car)
             // Draw the trail even when finished/showing score
             if ((gameState === 'CAR_ANIMATING' || gameState === 'SHOWING_SCORE' || isFinishing) && carTrail.length > 1) {
                 ctx.beginPath();
                 ctx.moveTo(carTrail[0].x, carTrail[0].y);
                 for (let i = 1; i < carTrail.length; i++) {
                     ctx.lineTo(carTrail[i].x, carTrail[i].y);
                 }
                 ctx.strokeStyle = 'rgba(255, 68, 68, 0.5)'; // Red trail color
                 ctx.lineWidth = 3;
                 ctx.lineCap = 'round';
                 ctx.lineJoin = 'round';
                 ctx.stroke();
             }

            // 2.5 Draw Tire Marks (after trail, before decorations/car)
            // Draw tire marks even when finished/showing score
            if (gameState === 'CAR_ANIMATING' || gameState === 'SHOWING_SCORE' || isFinishing) {
                ctx.strokeStyle = 'rgba(40, 40, 40, 0.7)'; // Dark semi-transparent color for lines
                ctx.lineWidth = 3; // Width of the tire mark lines
                ctx.lineCap = 'round'; // Make line ends rounded
                tireMarks.forEach(mark => {
                    if (mark.start && mark.end) { // Ensure we have both points
                        ctx.beginPath();
                        ctx.moveTo(mark.start.x, mark.start.y);
                        ctx.lineTo(mark.end.x, mark.end.y);
                        ctx.stroke();
                    }
                });
            }


            // 3. Create a list of drawable items (decorations, P2 path, car)
            let drawableItems = [...decorations]; // Start with decorations

            // Add P2 Path wrapper ONLY if P2 is drawing or waiting (NO LONGER NEEDED - Trail covers it)
            // if ((gameState === 'P2_DRAWING' || gameState === 'P2_WAITING') && player2Path.length > 0) { ... } // Remove or comment out

            // Add ONLY the Car sprite wrapper if animating OR finished/showing score
             if ((gameState === 'CAR_ANIMATING' || gameState === 'SHOWING_SCORE' || isFinishing) && carPosition) {
                 drawableItems.push({
                    getLowestY: () => {
                        const carHeight = CAR_CONSTANTS?.HEIGHT || 20;
                        return carPosition.y + carHeight / 2;
                    },
                    draw: (context) => {
                        // Only draw the car sprite here
                        drawCar(context, carPosition, currentCarAngle, currentWheelAngle, carConfig || { color: '#FF4444' });
                    }
                });
            }

            // 4. Sort all drawable items by their lowest Y coordinate
            drawableItems = drawableItems.filter(item => item && typeof item.getLowestY === 'function' && typeof item.draw === 'function');
            drawableItems.sort((a, b) => a.getLowestY() - b.getLowestY());

            // 5. Draw the sorted items (decorations, car)
            drawableItems.forEach(item => item.draw(ctx));

            // 6. Draw UI elements last (on top of everything)
            drawFuelGauge();
        }

        // --- Game Logic ---
        function resetPlayer2() {
            player2Path = [];
            isDrawing = false;
            lastPlayedProgressMilestone = 0;
            currentActiveSegmentIndex = 0; // Reset the active segment index
            currentPathLength = 0; // Reset path length
            gameState = 'P2_WAITING';
            statusDiv.textContent = 'Pelaaja 2: Seuraa polkua harmaasta ympyr√§st√§ alkaen.';
            redrawAll();
            saveP1CourseButton.style.display = 'none'; // Hide P1 save button
        }

        function resetGame() {
            // Hide screens
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('defeatScreen').style.display = 'none';
            
            gameState = 'P1_DRAWING';
            player1Path = [];
            smoothedPath = [];
            player2Path = [];
            isDrawing = false;
            player1TotalLength = 0;
            lastPlayedProgressMilestone = 0;
            startMarker = null;
            endMarker = null;
            progressMarkers = [];
            currentActiveSegmentIndex = 0;
            maxAllowedPathLength = 0; // Reset max allowed path length
            currentPathLength = 0;
            fuelConsumed = 0; // Reset fuel consumed
            previousCarPosition = null; // Reset previous car position tracking
            defeatFlagged = false; // Reset defeat flag
            isFinishing = false; // Reset finishing flag
            carConfig = null; // Reset car configuration
            decorations = []; // Clear decorations array
            tireMarks = []; // Clear tire marks
            // Reset session high score when starting a completely new game
            currentSessionHighScore = 0;
            currentSessionBestPlayer2Path = [];
            doneButton.style.display = 'inline-block';
            saveP1CourseButton.style.display = 'inline-block'; // Show P1 save button
            saveP1CourseButton.disabled = false; // Ensure it's enabled
            saveP1CourseButton.textContent = 'Tallenna rata'; // Reset text
            resetButton.style.display = 'none';
            statusDiv.textContent = 'Pelaaja 1: Piirr√§ polku.';
            
            // Reset car state
            if (carAnimationFrame) {
                cancelAnimationFrame(carAnimationFrame);
                carAnimationFrame = null;
            }
            carProgress = 0;
            carPosition = { x: 0, y: 0 };
            carAngle = 0;
            
            // Stop engine sound if playing
            if (engineSound) {
                engineSound.mainOsc.stop();
                engineSound.varOsc.stop();
                engineSound = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            isScreeching = false; // <--- Reset screeching state
            savedCoursesButton.style.display = 'inline-block'; // Show button in P1 phase
            closeSidebar(); // Ensure sidebar is closed on new game
            hideTrashCan(); // Ensure trashcan is hidden
            
            // Clear particles
            activeParticles = [];
            
            // Cancel particle animation if running
            if (particleAnimationFrame) {
                cancelAnimationFrame(particleAnimationFrame);
                particleAnimationFrame = null;
            }
        }

        // --- Event Handlers ---
        function handleStart(e) {
            if (e.touches && e.touches.length > 1) return;
            e.preventDefault();
            setHasInteracted(true);

            const pos = getEventCoords(e);

            if (gameState === 'P1_DRAWING') {
                isDrawing = true;
                player1Path = [pos];
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            } else if (gameState === 'P2_WAITING') {
                if (startMarker && dist(pos, startMarker) <= startMarker.snapRadius) {
                    isDrawing = true;
                    player2Path = [pos];
                    lastPlayedProgressMilestone = 0;
                    gameState = 'P2_DRAWING';
                    statusDiv.textContent = 'Pelaaja 2: Seuraa polkua! Pysy sinisen viivan sis√§ll√§!';
                    redrawAll();
                    drawPath(player2Path, P2_COLOR, P2_WIDTH, false);
                } else {
                    statusDiv.textContent = 'Pelaaja 2: Aloita piirt√§minen harmaasta ympyr√§st√§!';
                }
            }
        }

        function handleMove(e) {
            if (!isDrawing || (e.touches && e.touches.length > 1)) return;
            e.preventDefault();

            const pos = getEventCoords(e);
            const lastPos = (gameState === 'P1_DRAWING' ? player1Path : player2Path).slice(-1)[0];

            if (pos.x === lastPos.x && pos.y === lastPos.y) return;

            if (gameState === 'P1_DRAWING') {
                player1Path.push(pos);
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = P1_COLOR;
                ctx.lineWidth = P1_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();

            } else if (gameState === 'P2_DRAWING') {
                const threshold = P1_WIDTH / 2 * HIT_THRESHOLD_FACTOR;
                if (!isPointWithinPath(pos, player1Path, threshold)) {
                    playSound('alarm');
                    resetPlayer2();
                    statusDiv.textContent = 'Pelaaja 2: Hups! Eksyit polulta! Aloita uudelleen alusta.';
                    return;
                }

                // Calculate new path length
                const newSegmentLength = dist(lastPos, pos);
                currentPathLength += newSegmentLength;

                // Check if we've exceeded the fuel limit using the same calculation as car animation
                const progress = getProgressAlongPath(pos, player1Path);
                const effectivePathLength = progress * player1TotalLength;
                
                if (effectivePathLength > maxAllowedPathLength) {
                    defeatFlagged = true;
                    isDrawing = false; // Stop drawing
                    gameState = 'SHOWING_SCORE'; // Change state to show score
                    statusDiv.textContent = 'Pelaaja 2: Polttoaine loppui! Yrit√§ ajaa suoremmin.';
                    playSound('alarm');
                    playSound('alarm');
                    
                    // Add crash effect at the current position
                    activeParticles.push(...createCrashEffect(pos.x, pos.y));
                    
                    // Start particle animation immediately
                    animateParticles();
                    
                    // Add 1-second delay before showing defeat screen
                    setTimeout(() => {
                        drawFailState();
                    }, 1000);
                    
                    return; // Exit the function without showing defeat screen immediately
                }
                
                player2Path.push(pos);
                
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = P2_COLOR;
                ctx.lineWidth = P2_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();

                const currentProgress = getProgressAlongPath(pos, player1Path);
                const currentMilestone = Math.floor(currentProgress / PROGRESS_INTERVAL);

                if (currentMilestone > lastPlayedProgressMilestone && currentProgress < 1.0) {
                    lastPlayedProgressMilestone = currentMilestone;
                    playSound('chime', currentProgress);
                }
            }
        }

        function handleEnd(e) {
            if (!isDrawing) return;
            e.preventDefault();

            if (gameState === 'P1_DRAWING') {
                isDrawing = false;
                if (player1Path.length < 2) {
                    statusDiv.textContent = "Pelaaja 1: Polku on liian lyhyt! Piirr√§ pitempi polku.";
                } else {
                    statusDiv.textContent = "Pelaaja 1: Paina 'Valmis' tai jatka piirt√§mist√§.";
                }
            } else if (gameState === 'P2_DRAWING') {
                const lastPos = player2Path.slice(-1)[0];
                isDrawing = false;

                if (endMarker && dist(lastPos, endMarker) <= endMarker.snapRadius) {
                    const finalProgress = getProgressAlongPath(lastPos, player1Path);
                    if (finalProgress >= 0.95) {
                        gameState = 'CAR_ANIMATING';
                        statusDiv.textContent = 'Pelaaja 2: Polku valmis! Odota autoa...';
                        playSound('success');
                        redrawAll();
                        drawPath(player2Path, P2_COLOR, P2_WIDTH, false);
                        
                        // Reset car state and start animation
                        carProgress = 0;
                        carPosition = { ...player2Path[0] };
                        carAngle = 0;
                        carConfig = createCar(); // Create new car configuration with random color
                        animateCar();
                    } else {
                        playSound('alarm');
                        resetPlayer2();
                        statusDiv.textContent = 'Pelaaja 2: Saavutit maalin liian aikaisin! Aloita uudelleen alusta.';
                    }
                } else {
                    playSound('alarm');
                    resetPlayer2();
                    statusDiv.textContent = 'Pelaaja 2: Piirt√§minen keskeytyi! Aloita uudelleen alusta.';
                }
            }
        }

        function calculateScore() {
            if (!player2Path || player2Path.length < 2 || !smoothedPath || smoothedPath.length < 2) return 0; // Added check for smoothedPath

            let totalDistance = 0;
            let validPoints = 0;

            // Sample points along Player 2's path
            for (let i = 0; i < player2Path.length; i++) {
                const point = player2Path[i];
                let minDistance = Infinity;

                // Find the closest point on the defined Player 1 course path (smoothedPath)
                for (let j = 0; j < smoothedPath.length - 1; j++) {
                    const dist = pointLineSegmentDistance(point, smoothedPath[j], smoothedPath[j + 1]);
                    minDistance = Math.min(minDistance, dist);
                }
                 // Check distance to the last point of smoothedPath as well
                 if (smoothedPath.length > 0) {
                     minDistance = Math.min(minDistance, dist(point, smoothedPath[smoothedPath.length - 1]));
                 }


                // Only count points that are within the threshold
                if (minDistance <= SCORE_THRESHOLD) {
                    totalDistance += minDistance;
                    validPoints++;
                }
            }
            
            if (validPoints === 0) return 0;
            
            // Calculate average distance
            const avgDistance = totalDistance / validPoints;
            
            // Convert to score (0-100)
            // Perfect score (100) when average distance is 0
            // 0 points when average distance is SCORE_THRESHOLD or greater
            const score = Math.max(0, Math.round(SCORE_POINTS * (1 - avgDistance / SCORE_THRESHOLD)));
            
            return score;
        }

        function getScoreMessage(score) {
            if (score >= 90) return "Vau! Upea suoritus! üåüüåüüåüüåüüåü";
            if (score >= 80) return "Ajoit varsin hienosti! üåüüåüüåüüåü";
            if (score >= 70) return "Hyv√§! Pysyit tiell√§! üåüüåüüåü";
            if (score >= 60) return "Pystyt parempaankin! üåüüåü";
            if (score >= 50) return "Nyt meni v√§h√§n mutkitellen! üåü";
            return "Kokeile uudelleen! üí™";
        }

        // --- Initialization ---
        function resizeCanvas() {
            const controlsHeight = document.getElementById('controls').offsetHeight + 20; // Get actual height + margin
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight; // Adjust if controls overlay canvas significantly

             // Style setting needed if CSS dimensions are different
             canvas.style.width = `${window.innerWidth}px`;
             canvas.style.height = `${window.innerHeight}px`;

             redrawAll(); // Redraw contents after resize
        }

        // Setup Event Listeners
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseout', handleEnd); // Treat leaving canvas like mouseup

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false }); // Treat cancel like end

        doneButton.addEventListener('click', handleP1Done);
        resetButton.addEventListener('click', resetGame);

        // Add width slider event listener
        const widthSlider = document.getElementById('widthSlider');
        const widthValue = document.getElementById('widthValue');
        widthSlider.addEventListener('input', (e) => {
            P1_WIDTH = parseInt(e.target.value);
            widthValue.textContent = P1_WIDTH;
            if (gameState === 'P1_DRAWING' && player1Path.length > 0) {
                redrawAll();
            }
        });

        window.addEventListener('resize', resizeCanvas);

        // Add event listeners for game screens
        document.getElementById('victoryReplayButton').addEventListener('click', replayLevel);
        document.getElementById('victoryNewGameButton').addEventListener('click', resetGame);
        document.getElementById('saveCourseButton').addEventListener('click', saveCurrentCourse); // Add listener for the new button
        document.getElementById('defeatReplayButton').addEventListener('click', replayLevel);
        document.getElementById('defeatNewGameButton').addEventListener('click', resetGame);

        // Add listeners for new UI elements
        savedCoursesButton.addEventListener('click', openSidebar);
        closeSidebarButton.addEventListener('click', closeSidebar);

        // Add Drag/Drop listeners for canvas (loading)
        canvas.addEventListener('dragover', handleCanvasDragOver);
        canvas.addEventListener('drop', handleCanvasDrop);

        // Add Drag/Drop listeners for trashcan (deleting)
        trashCan.addEventListener('dragover', handleTrashDragOver);
        trashCan.addEventListener('dragleave', handleTrashDragLeave); // Handle leaving the trash area
        trashCan.addEventListener('drop', handleTrashDrop);

        // Initial setup - WRAP these calls
        document.addEventListener('DOMContentLoaded', (event) => {
            resizeCanvas();
            resetGame(); // Initialize game state AFTER DOM is fully loaded
        });

        // Remove the original calls outside the listener:
        // resizeCanvas(); // <-- Remove this line
        // resetGame(); // <-- Remove this line

        function isPointInButton(point, buttonX, buttonY, buttonWidth, buttonHeight) {
            return point.x >= buttonX && 
                   point.x <= buttonX + buttonWidth && 
                   point.y >= buttonY && 
                   point.y <= buttonY + buttonHeight;
        }

        function handleVictoryFailClick(e) {
            // This function is no longer needed as we're using HTML buttons
            // that have their own event listeners
        }

        function replayLevel() {
            // Hide screens
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('defeatScreen').style.display = 'none';
            
            // Keep player1Path and smoothedPath, but reset everything else
            player2Path = [];
            isDrawing = false;
            lastPlayedProgressMilestone = 0;
            currentActiveSegmentIndex = 0;
            currentPathLength = 0;
            fuelConsumed = 0; // Reset fuel consumed for replay
            previousCarPosition = null; // Reset previous car position tracking
            defeatFlagged = false; // Reset defeat flag
            isFinishing = false; // Reset finishing flag
            carConfig = null; // Reset car configuration
            gameState = 'P2_WAITING';
            statusDiv.textContent = 'Pelaaja 2: Seuraa polkua harmaasta ympyr√§st√§ alkaen.';
            
            // Reset car state
            if (carAnimationFrame) {
                cancelAnimationFrame(carAnimationFrame);
                carAnimationFrame = null;
            }
            carProgress = 0;
            carPosition = { x: 0, y: 0 };
            carAngle = 0;
            carTrail = [];
            tireMarks = []; // <--- Clear tire marks
            isScreeching = false; // <--- Reset screeching state
            
            // Stop engine sound if playing
            if (engineSound) {
                engineSound.mainOsc.stop();
                engineSound.varOsc.stop();
                engineSound = null;
            }
            
            redrawAll();
            
            // Clear particles
            activeParticles = [];
            
            // Cancel particle animation if running
            if (particleAnimationFrame) {
                cancelAnimationFrame(particleAnimationFrame);
                particleAnimationFrame = null;
            }
        }

        function animateCar() {
            // Exit if we are already in the finishing delay or showing score
            if (isFinishing || gameState === 'SHOWING_SCORE') {
                // Start particle animation if not already running
                if (!particleAnimationFrame && activeParticles.length > 0) {
                    animateParticles();
                }
                return;
            }

            // Initialize previous position on the first frame
            if (previousCarPosition === null) {
                previousCarPosition = { ...carPosition };
                previousCarAngle = currentCarAngle; // Initialize previous angle too
            }

            // --- Car Movement Calculation ---
            // Calculate curvature, speed etc. based on the path the car is ACTUALLY following (player2Path)
            const posOnP2Path = getPointAlongPath(carProgress, player2Path);
            const currentCurvature = calculateCurvature(carProgress, player2Path);
            const upcomingProgress = Math.min(1, carProgress + CURVE_LOOK_AHEAD);
            const upcomingCurvature = calculateCurvature(upcomingProgress, player2Path);
            const targetSpeedMultiplier = getSpeedMultiplier(currentCurvature);
            let targetSpeed = CAR_PIXEL_SPEED * targetSpeedMultiplier;

            // --- (Speed adjustment near finish - might need rethinking if P1/P2 lengths differ significantly) ---
            const distanceToFinish = 1 - carProgress;
            if (distanceToFinish < FINISH_PREPARATION_DISTANCE) {
                 const finishFactor = distanceToFinish / FINISH_PREPARATION_DISTANCE;
                 const minSpeed = CAR_PIXEL_SPEED * MIN_FINISH_SPEED;
                 targetSpeed = minSpeed + (targetSpeed - minSpeed) * finishFactor;
            }

            const decelerationRate = getDecelerationRate(currentCurvature, upcomingCurvature);

            if (targetSpeed > currentSpeed) {
                 const speedDiff = targetSpeed - currentSpeed;
                 const accelerationRate = ACCELERATION_RATE * (1 + speedDiff / CAR_PIXEL_SPEED);
                 currentSpeed = Math.min(targetSpeed, currentSpeed + CAR_PIXEL_SPEED * accelerationRate);
            } else {
                 currentSpeed = Math.max(targetSpeed, currentSpeed - CAR_PIXEL_SPEED * decelerationRate);
            }

            // Calculate next position BEFORE checking fuel
            const progressIncrement = (currentSpeed / player1TotalLength);
            const nextProgress = carProgress + progressIncrement;
            const nextPos = getPointAlongPath(nextProgress, player2Path);
            const distanceMoved = dist(carPosition, nextPos);

            // --- Fuel Check ---
            // Check if this next move would exceed fuel limit
            if (fuelConsumed + distanceMoved > maxAllowedPathLength && !defeatFlagged) {
                defeatFlagged = true;
                playSound('alarm');
                playSound('alarm');
                statusDiv.textContent = 'Pelaaja 2: Polttoaine loppui! Yrit√§ ajaa suoremmin.';
                
                // Add crash effect at the current position
                activeParticles.push(...createCrashEffect(carPosition.x, carPosition.y));
                
                // Start particle animation immediately
                if (!particleAnimationFrame) {
                    animateParticles();
                }
                
                // Stop the car immediately
                if (carAnimationFrame) {
                    cancelAnimationFrame(carAnimationFrame);
                    carAnimationFrame = null;
                }
                
                // Stop engine sound
                if (engineSound) {
                    engineSound.mainOsc.stop();
                    engineSound.varOsc.stop();
                    engineSound = null;
                }
                
                // Set timeout to show defeat screen after 1 second
                setTimeout(() => {
                    gameState = 'SHOWING_SCORE';
                    drawFailState();
                }, 1000);
                
                return; // Exit the animation function
            }

            // --- Update Car State ---
            previousCarPosition = { ...carPosition };
            carPosition = nextPos;
            carProgress = nextProgress;
            carTrail.push({ ...carPosition });
            fuelConsumed += distanceMoved;

            // --- Update Car Angle and Sounds ---
            const direction = getDirectionAlongPath(carProgress, player2Path);
            const targetCarAngle = Math.atan2(direction.y, direction.x);
            const angleDiff = targetCarAngle - currentCarAngle;
            const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
            currentCarAngle += normalizedDiff * CAR_TURN_SPEED;

            // Determine if the car should be screeching in this frame
            const shouldBeScreeching = Math.abs(normalizedDiff) > TURN_THRESHOLD;

            // Check if screeching just started
            if (shouldBeScreeching && !isScreeching) {
                playSound('screech');
            }

            // Update the screeching state for the current frame
            isScreeching = shouldBeScreeching;

            // Add tire marks if currently screeching
            if (isScreeching) {
                // --- Add Tire Marks ---
                const carWidth = CAR_CONSTANTS?.WIDTH || 15;
                const carLength = CAR_CONSTANTS?.HEIGHT || 25;
                const halfW = carWidth / 2;
                const halfL = carLength / 2;

                const tireOffsets = [
                    { x: halfW, y: -halfL }, { x: -halfW, y: -halfL },
                    { x: halfW, y: halfL }, { x: -halfW, y: halfL }
                ];

                const calculateTirePositions = (centerPos, angle) => {
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);
                    return tireOffsets.map(offset => {
                        const rotatedX = offset.x * cosA - offset.y * sinA;
                        const rotatedY = offset.x * sinA + offset.y * cosA;
                        return { x: centerPos.x + rotatedX, y: centerPos.y + rotatedY };
                    });
                };

                const currentTirePositions = calculateTirePositions(carPosition, currentCarAngle);
                if (previousCarPosition && previousCarAngle !== undefined) {
                    const previousTirePositions = calculateTirePositions(previousCarPosition, previousCarAngle);

                    for (let i = 0; i < 4; i++) {
                        if (distSq(previousTirePositions[i], currentTirePositions[i]) > 0.1) {
                             tireMarks.push({
                                start: previousTirePositions[i],
                                end: currentTirePositions[i]
                            });
                        }
                    }
                }
            }

            // Store current angle as previous for the next frame
            previousCarAngle = currentCarAngle;

            if (!engineSound) {
                engineSound = playSound('engine');
            } else {
                engineSound.updateSpeed(currentSpeed, CAR_PIXEL_SPEED);
            }

            // --- Redraw and Continue Animation ---
            redrawAll();

            // --- Finish Line Check ---
            // Check only if not already in the finishing delay phase
            if (!isFinishing && carProgress >= 1) {
                isFinishing = true; // Set the finishing flag
                currentSpeed = 0; // Stop the car immediately

                // Play honk sound immediately IF NOT defeated
                if (!defeatFlagged) {
                    playHonk([0.1, 0.6], [0.1]);
                    
                    // Calculate score before showing victory screen
                    const score = calculateScore();
                    
                    // Only add victory celebration particles if this is a new high score
                    if (score > currentSessionHighScore) {
                        // Add victory celebration particles immediately
                        activeParticles.push(...createVictoryCelebration(carPosition.x, carPosition.y));
                        // Start particle animation if not already running
                        if (!particleAnimationFrame) {
                            animateParticles();
                        }
                    }
                }

                // Stop engine sound
                if (engineSound) {
                    engineSound.mainOsc.stop();
                    engineSound.varOsc.stop();
                    engineSound = null;
                }

                // Cancel future animation frames
                if (carAnimationFrame) {
                    cancelAnimationFrame(carAnimationFrame);
                    carAnimationFrame = null;
                }

                // Perform one final redraw to show the car at the finish line
                redrawAll();

                // Set timeout to show the appropriate screen after 1 second
                setTimeout(() => {
                    gameState = 'SHOWING_SCORE';
                    if (defeatFlagged) {
                        drawFailState();
                    } else {
                        const score = calculateScore();
                        statusDiv.textContent = `Pisteet: ${score} - ${getScoreMessage(score)}`;
                        showVictoryScreen(score);
                    }
                }, 1000);

                return;
            }

            // Request next frame only if not finishing
            if (!isFinishing) {
                carAnimationFrame = requestAnimationFrame(animateCar);
            }
        }

        // --- Path Saving Logic ---

        function saveCurrentCourse() {
            // This function now ONLY handles the FIRST save of a course
            const saveButton = document.getElementById('saveCourseButton');

            if (!smoothedPath || smoothedPath.length < 2) {
                console.error("Cannot save: No valid Player 1 path exists.");
                alert("Rataa ei voi tallentaa, koska Pelaaja 1:n polkua ei ole piirretty kunnolla.");
                return;
            }
            // Basic check for session score, though it might be 0 on first successful run
             if (currentSessionHighScore <= 0 || !currentSessionBestPlayer2Path || currentSessionBestPlayer2Path.length < 2) {
                 console.warn("Saving course with potentially zero score or missing P2 path for the session.");
             }

            const courseId = hashPath(smoothedPath);
            const courseName = `Rata ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;

            const newCourseData = {
                id: courseId,
                name: courseName,
                player1Path: smoothedPath,
                highScore: currentSessionHighScore, // Save the best score from the session
                highScorePlayer2Path: currentSessionBestPlayer2Path
            };

            try {
                let savedCourses = JSON.parse(localStorage.getItem('savedCourses') || '[]');
                const existingCourseIndex = savedCourses.findIndex(course => course.id === courseId);

                if (existingCourseIndex === -1) {
                    // --- Add new course ---
                    savedCourses.push(newCourseData);
                    localStorage.setItem('savedCourses', JSON.stringify(savedCourses));
                    console.log(`Course saved for the first time: ${newCourseData.name}`, newCourseData);
                    saveButton.textContent = 'Tallennettu!'; // Feedback for new save
                    saveButton.disabled = true;
                } else {
                    // Course somehow already exists - this shouldn't happen if showVictoryScreen logic is correct
                    // but handle defensively. Button should already be disabled in this case.
                    console.warn(`Save button clicked, but course ${courseId} already exists.`);
                    saveButton.textContent = 'Rata tallennettu'; // Reflect state
                    saveButton.disabled = true;
                }

            } catch (error) {
                console.error("Error saving new course to localStorage:", error);
                alert("Radan tallentamisessa tapahtui virhe.");
                saveButton.textContent = 'Tallennus ep√§onnistui';
                saveButton.disabled = false; // Allow retry?
            }
        }

        // Add these hashing functions
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = char + (hash << 6) + (hash << 16) - hash;
            }
            // Convert to a positive hexadecimal string prefixed with 'h_'
            return `h_${(hash >>> 0).toString(16)}`;
        }

        function hashPath(path) {
            if (!path || path.length === 0) return 'h_empty';
            // Stringify with fixed precision to handle floating point variations
            const pathString = JSON.stringify(path.map(p => ({ x: p.x.toFixed(3), y: p.y.toFixed(3) })));
            return simpleHash(pathString);
        }

        // --- UI Functions ---

        function openSidebar() {
            populateSavedCoursesSidebar(); // Load content when opening
            savedCoursesSidebar.classList.add('visible');
        }

        function closeSidebar() {
            savedCoursesSidebar.classList.remove('visible');
        }

        function showTrashCan() {
            trashCan.style.display = 'block';
        }

        function hideTrashCan() {
            trashCan.style.display = 'none';
            trashCan.classList.remove('active-drop'); // Remove hover effect
        }

        function getStarRatingHTML(score) {
            const maxStars = 5;
            let stars = 0;
            if (score >= 90) stars = 5;
            else if (score >= 80) stars = 4;
            else if (score >= 70) stars = 3;
            else if (score >= 60) stars = 2;
            else if (score >= 50) stars = 1;

            let html = '';
            for (let i = 0; i < stars; i++) {
                html += '‚≠ê'; // Full star
            }
            for (let i = stars; i < maxStars; i++) {
                // html += '‚òÜ'; // Outline star (optional)
            }
            return html;
        }

        function drawThumbnail(canvasElement, path) {
            const thumbCtx = canvasElement.getContext('2d');
            const width = canvasElement.width;
            const height = canvasElement.height;

            thumbCtx.clearRect(0, 0, width, height);

            if (!path || path.length < 2) return;

            // Find path bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            const pathWidth = maxX - minX;
            const pathHeight = maxY - minY;

            // Handle cases where path is a point or a straight vertical/horizontal line
            const effectivePathWidth = pathWidth === 0 ? 1 : pathWidth; // Give it minimal width/height if zero
            const effectivePathHeight = pathHeight === 0 ? 1 : pathHeight;

            // Calculate scale to fit within padded area
            const availableWidth = width - 2 * THUMBNAIL_PADDING;
            const availableHeight = height - 2 * THUMBNAIL_PADDING;
            // Ensure available dimensions are positive
            if (availableWidth <= 0 || availableHeight <= 0) return;

            const scale = Math.min(availableWidth / effectivePathWidth, availableHeight / effectivePathHeight);

            // Calculate translation to center the scaled path
            const scaledWidth = effectivePathWidth * scale;
            const scaledHeight = effectivePathHeight * scale;
            const offsetX = THUMBNAIL_PADDING + (availableWidth - scaledWidth) / 2;
            const offsetY = THUMBNAIL_PADDING + (availableHeight - scaledHeight) / 2;
            // Adjust translation based on the original min points and the calculated scale/offset
            const translateX = offsetX - minX * scale;
            const translateY = offsetY - minY * scale;

            // Draw the scaled path
            thumbCtx.strokeStyle = P1_COLOR;
            thumbCtx.lineWidth = 5; // Increased line width to match marker size visually
            thumbCtx.lineCap = 'round';
            thumbCtx.lineJoin = 'round';
            thumbCtx.beginPath();
            thumbCtx.moveTo(path[0].x * scale + translateX, path[0].y * scale + translateY);
            for (let i = 1; i < path.length; i++) {
                thumbCtx.lineTo(path[i].x * scale + translateX, path[i].y * scale + translateY);
            }
            thumbCtx.stroke();

            // Draw start/end markers (size remains 5)
            thumbCtx.fillStyle = START_COLOR;
            thumbCtx.beginPath();
            thumbCtx.arc(path[0].x * scale + translateX, path[0].y * scale + translateY, 5, 0, Math.PI*2);
            thumbCtx.fill();

            // Ensure there's a distinct end point before drawing the end marker
            if (path.length > 1) {
                thumbCtx.fillStyle = END_COLOR;
                thumbCtx.beginPath();
                thumbCtx.arc(path[path.length-1].x * scale + translateX, path[path.length-1].y * scale + translateY, 5, 0, Math.PI*2);
                thumbCtx.fill();
            }
        }

        function populateSavedCoursesSidebar() {
            sidebarContent.innerHTML = ''; // Clear existing content
            try {
                const savedCourses = JSON.parse(localStorage.getItem('savedCourses') || '[]');
                if (savedCourses.length === 0) {
                    sidebarContent.innerHTML = '<p style="text-align: center; color: #666;">Ei tallennettuja ratoja.</p>';
                    return;
                }

                savedCourses.forEach(course => {
                    if (!course || !course.id || !course.player1Path) {
                        console.warn("Skipping invalid course data:", course);
                        return;
                    }

                    const container = document.createElement('div');
                    container.className = 'thumbnail-container';
                    container.draggable = true;
                    container.dataset.courseId = course.id; // Store ID for drag/drop

                    const canvasEl = document.createElement('canvas');
                    canvasEl.className = 'thumbnail-canvas';
                    canvasEl.width = THUMBNAIL_WIDTH; // Set canvas drawing size
                    canvasEl.height = THUMBNAIL_HEIGHT;

                    const starsEl = document.createElement('div');
                    starsEl.className = 'thumbnail-stars';
                    starsEl.innerHTML = getStarRatingHTML(course.highScore || 0);

                    container.appendChild(canvasEl);
                    container.appendChild(starsEl);
                    sidebarContent.appendChild(container);

                    // Draw after appending (sometimes needed for context)
                    drawThumbnail(canvasEl, course.player1Path);

                    // Add drag listeners to the container
                    container.addEventListener('dragstart', handleThumbnailDragStart);
                    container.addEventListener('dragend', handleThumbnailDragEnd);
                });

            } catch (error) {
                console.error("Error loading saved courses for sidebar:", error);
                sidebarContent.innerHTML = '<p style="color: red;">Radan lataus ep√§onnistui.</p>';
            }
        }

        // --- Course Loading/Deleting ---

        function loadCourse(courseData) {
            if (!courseData || !courseData.player1Path) {
                console.error("Invalid course data provided for loading.");
                return;
            }
            console.log(`Loading course: ${courseData.name} (ID: ${courseData.id})`);

            // Reset current game state partially (like resetGame but keep sidebar open?)
            // Hide screens first
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('defeatScreen').style.display = 'none';

            // Reset relevant state vars
            player1Path = courseData.player1Path; // Use the loaded path
            smoothedPath = [...player1Path]; // Set smoothedPath as well (assuming raw path is used)
            player2Path = [];
            isDrawing = false;
            lastPlayedProgressMilestone = 0;
            startMarker = null; // Will be recalculated
            endMarker = null;   // Will be recalculated
            progressMarkers = [];
            currentActiveSegmentIndex = 0;
            maxAllowedPathLength = 0;
            currentPathLength = 0;
            fuelConsumed = 0;
            previousCarPosition = null;
            defeatFlagged = false;
            carConfig = null;
            decorations = [];
            tireMarks = [];

            // IMPORTANT: Set the session high score from the loaded course
            currentSessionHighScore = courseData.highScore || 0;
            currentSessionBestPlayer2Path = courseData.highScorePlayer2Path || [];

            // Update controls visibility
            doneButton.style.display = 'none'; // P1 is done by loading
            saveP1CourseButton.style.display = 'none'; // Hide P1 save button too
            resetButton.style.display = 'inline-block';

            // Stop any ongoing car animation/sound
            if (carAnimationFrame) cancelAnimationFrame(carAnimationFrame);
            carAnimationFrame = null;
            if (engineSound) { engineSound.mainOsc.stop(); engineSound.varOsc.stop(); engineSound = null; }
            carProgress = 0; carPosition = { x: 0, y: 0 }; carAngle = 0; carTrail = []; isScreeching = false;

            // Now, trigger the logic similar to handleP1Done to set up P2 phase
            // This recalculates markers, length, decorations based on the loaded player1Path
            handleP1Done(); // This sets gameState to 'P2_WAITING' and redraws

            closeSidebar(); // Close sidebar after loading
            statusDiv.textContent = `Ladattu rata: ${courseData.name}. Pelaaja 2: Seuraa polkua.`;
        }

        function deleteCourse(courseId) {
             if (!courseId) return;
             console.log(`Attempting to delete course: ${courseId}`);
            try {
                let savedCourses = JSON.parse(localStorage.getItem('savedCourses') || '[]');
                const initialLength = savedCourses.length;
                savedCourses = savedCourses.filter(course => course.id !== courseId);

                if (savedCourses.length < initialLength) {
                    localStorage.setItem('savedCourses', JSON.stringify(savedCourses));
                    console.log(`Course ${courseId} deleted.`);
                    // Refresh the sidebar to remove the thumbnail visually
                    populateSavedCoursesSidebar();
                    return true; // Indicate success
                } else {
                    console.warn(`Course ${courseId} not found for deletion.`);
                    return false;
                }
            } catch (error) {
                console.error("Error deleting course:", error);
                alert("Radan poistaminen ep√§onnistui.");
                return false;
            }
        }

        // --- Drag and Drop Handlers ---

        function handleThumbnailDragStart(e) {
            // Check if it's a valid thumbnail container
            if (e.target.classList.contains('thumbnail-container')) {
                draggedCourseId = e.target.dataset.courseId;
                e.dataTransfer.setData('text/plain', draggedCourseId);
                e.dataTransfer.effectAllowed = 'move'; // Indicate moving is allowed
                showTrashCan(); // Show trashcan when dragging starts
                // Optional: Add a dragging style to the thumbnail
                e.target.style.opacity = '0.5';
            } else {
                e.preventDefault(); // Prevent dragging if not the container
            }
        }

        function handleThumbnailDragEnd(e) {
             // Check if it's a valid thumbnail container ending drag
             if (e.target.classList.contains('thumbnail-container')) {
                // Restore appearance
                e.target.style.opacity = '1';
                hideTrashCan(); // Always hide trashcan when drag ends
                draggedCourseId = null; // Clear the dragged ID
             }
        }

        function handleCanvasDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move'; // Indicate dropping is possible
            // Optional: Add visual feedback to canvas (e.g., border)
        }

        function handleCanvasDrop(e) {
            e.preventDefault();
            const courseId = e.dataTransfer.getData('text/plain');
            if (courseId) {
                 try {
                    const savedCourses = JSON.parse(localStorage.getItem('savedCourses') || '[]');
                    const courseToLoad = savedCourses.find(c => c.id === courseId);
                    if (courseToLoad) {
                        loadCourse(courseToLoad);
                    } else {
                        console.error(`Course with ID ${courseId} not found in localStorage.`);
                    }
                 } catch (error) {
                     console.error("Error loading course on drop:", error);
                 }
            }
             hideTrashCan(); // Hide trash after drop
        }

        function handleTrashDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            trashCan.classList.add('active-drop'); // Highlight trashcan
        }

         function handleTrashDragLeave(e) {
             trashCan.classList.remove('active-drop'); // Remove highlight
         }

        function handleTrashDrop(e) {
            e.preventDefault();
            const courseId = e.dataTransfer.getData('text/plain');
            if (courseId) {
                // Optional: Add a confirmation dialog
                // if (confirm(`Haluatko varmasti poistaa t√§m√§n radan?`)) {
                     deleteCourse(courseId);
                // }
            }
            hideTrashCan(); // Hide trashcan after drop
        }

        // NEW function for P1 saving during drawing phase
        function saveP1CourseNow() {
            if (gameState !== 'P1_DRAWING') {
                console.warn("Attempted to save P1 course outside of P1 drawing phase.");
                return;
            }

            if (!player1Path || player1Path.length < 2) {
                alert("Rataa ei voi tallentaa, koska polku on liian lyhyt!");
                return;
            }

            // Use the current P1 path for hashing and saving
            const coursePathToSave = [...player1Path]; // Create a copy
            const courseId = hashPath(coursePathToSave);
            const courseName = `Rata ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;

            const newCourseData = {
                id: courseId,
                name: courseName,
                player1Path: coursePathToSave,
                highScore: 0, // No high score yet
                highScorePlayer2Path: [] // No P2 path yet
            };

            try {
                let savedCourses = JSON.parse(localStorage.getItem('savedCourses') || '[]');
                const existingCourseIndex = savedCourses.findIndex(course => course.id === courseId);

                if (existingCourseIndex !== -1) {
                    // Course with this exact path already exists
                    alert("T√§m√§ rata on jo tallennettu.");
                    // Optional: Briefly change button text
                    saveP1CourseButton.textContent = 'Jo tallennettu';
                    setTimeout(() => { saveP1CourseButton.textContent = 'Tallenna rata'; }, 1500);
                } else {
                    // --- Add new course ---
                    savedCourses.push(newCourseData);
                    localStorage.setItem('savedCourses', JSON.stringify(savedCourses));
                    console.log(`P1 course saved: ${newCourseData.name}`, newCourseData);

                    // Provide feedback on the button
                    saveP1CourseButton.textContent = 'Tallennettu!';
                    saveP1CourseButton.disabled = true;
                    setTimeout(() => {
                        saveP1CourseButton.textContent = 'Tallenna rata';
                        saveP1CourseButton.disabled = false;
                    }, 1500); // Reset after 1.5 seconds

                    // If the sidebar is open, refresh it
                    if (savedCoursesSidebar.classList.contains('visible')) {
                        populateSavedCoursesSidebar();
                    }
                }

            } catch (error) {
                console.error("Error saving P1 course to localStorage:", error);
                alert("Radan tallentamisessa tapahtui virhe.");
            }
        }

        // Add these hashing functions (if not already present from previous steps)
        // function simpleHash(str) { ... }
        // function hashPath(path) { ... }

        // --- Course Loading/Deleting ---
        // ... (existing loadCourse code before button visibility) ...
        doneButton.style.display = 'none'; // P1 is done by loading
        saveP1CourseButton.style.display = 'none'; // Hide P1 save button too
        resetButton.style.display = 'inline-block';
        // ... (rest of loadCourse code) ...

        // --- Initialization ---
        // ...

        // Setup Event Listeners
        // ... (existing canvas, doneButton, resetButton listeners) ...
        saveP1CourseButton.addEventListener('click', saveP1CourseNow); // Add listener for the new button

        // ... (existing width slider, window resize, game screen button listeners) ...

        // Add listeners for new UI elements (sidebar, etc.)
        // ...

        // Add Drag/Drop listeners
        // ...

        // Initial setup
        // ...

        // Add new function for particle animation
        function animateParticles() {
            // Clear the canvas and redraw everything
            redrawAll();
            
            // Update and draw particles on top
            updateAndDrawParticles(ctx, activeParticles);
            
            // Continue animation if there are particles
            if (activeParticles.length > 0) {
                particleAnimationFrame = requestAnimationFrame(animateParticles);
            } else {
                // If no particles left, ensure we clean up
                particleAnimationFrame = null;
            }
        }
    </script>
</body>
</html>
